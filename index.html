<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é«˜ä¸­ç‰©ç†AIæƒ…å¢ƒæ¢ç©¶å¹³å°</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            padding: 20px;
            color: #333;
            min-width: 1200px;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #4b6cb7 0%, #182848 100%);
            color: white;
            padding: 25px 30px;
            text-align: center;
        }
        
        h1 {
            font-size: 28px;
            margin-bottom: 8px;
        }
        
        .subtitle {
            font-size: 16px;
            opacity: 0.9;
            font-weight: normal;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 450px 1fr;
            gap: 20px;
            padding: 20px;
        }
        
        .left-panel {
            background-color: #f9fafc;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .right-panel {
            display: grid;
            grid-template-rows: auto 1fr;
            gap: 20px;
        }
        
        .motion-section {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }
        
        .charts-section {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
        }
        
        .section {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.05);
        }
        
        .section-title {
            font-size: 18px;
            color: #2c3e50;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #eaeef2;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .object-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        .object-panel {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
        }
        
        .object-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 15px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
            color: #2c3e50;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .object-status {
            font-size: 12px;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: normal;
        }
        
        .status-moving {
            background-color: #2ecc71;
            color: white;
        }
        
        .status-stopped {
            background-color: #e74c3c;
            color: white;
        }
        
        .status-braking {
            background-color: #f39c12;
            color: white;
        }
        
        .object-a .object-title {
            color: #3498db;
        }
        
        .object-b .object-title {
            color: #e74c3c;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #555;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
            -webkit-appearance: none;
        }
        
        .object-a input[type="range"]::-webkit-slider-thumb {
            background-color: #3498db;
        }
        
        .object-b input[type="range"]::-webkit-slider-thumb {
            background-color: #e74c3c;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .number-input-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .number-input {
            width: 80px;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            text-align: center;
            background-color: white;
        }
        
        .number-input:focus {
            outline: none;
            border-color: #4b6cb7;
            box-shadow: 0 0 0 2px rgba(75, 108, 183, 0.2);
        }
        
        .input-buttons {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .input-btn {
            width: 24px;
            height: 18px;
            border: 1px solid #ddd;
            background-color: #f5f5f5;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            user-select: none;
        }
        
        .input-btn:hover {
            background-color: #e0e0e0;
        }
        
        .input-btn:active {
            background-color: #d0d0d0;
        }
        
        .input-btn.up {
            border-radius: 4px 4px 0 0;
        }
        
        .input-btn.down {
            border-radius: 0 0 4px 4px;
        }
        
        .value-display {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            color: #2c3e50;
        }
        
        .buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }
        
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            background-color: #4b6cb7;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            flex: 1;
            min-width: 120px;
        }
        
        button:hover {
            background-color: #3a5795;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        button.reset {
            background-color: #95a5a6;
        }
        
        button.reset:hover {
            background-color: #7f8c8d;
        }
        
        button.play {
            background-color: #2ecc71;
        }
        
        button.play:hover {
            background-color: #27ae60;
        }
        
        button.pause {
            background-color: #e67e22;
        }
        
        button.pause:hover {
            background-color: #d35400;
        }
        
        button.secondary {
            background-color: #ecf0f1;
            color: #2c3e50;
            padding: 8px 12px;
            min-width: auto;
        }
        
        button.secondary:hover {
            background-color: #d5dbdb;
        }
        
        .checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 14px;
            cursor: pointer;
        }
        
        .checkbox-label input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }
        
        #motionCanvas {
            width: 100%;
            height: 300px;
            border-radius: 8px;
            background-color: #f8f9fa;
            border: 1px solid #eaeef2;
            cursor: grab;
        }
        
        #motionCanvas:active {
            cursor: grabbing;
        }
        
        .special-moments {
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #eaeef2;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .moment-list {
            margin-top: 10px;
            flex-grow: 1;
            overflow-y: auto;
        }
        
        .moment-item {
            padding: 8px 12px;
            margin-bottom: 8px;
            background-color: white;
            border-radius: 6px;
            border-left: 4px solid #4b6cb7;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .moment-item:hover {
            background-color: #e8f4fd;
            transform: translateX(5px);
        }
        
        .moment-item.active {
            background-color: #d1ecf1;
            border-left-color: #17a2b8;
        }
        
        .moment-time {
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 3px;
            display: flex;
            justify-content: space-between;
        }
        
        .moment-description {
            font-size: 13px;
            color: #666;
        }
        
        .chart-container {
            height: 230px;
            width: 100%;
        }
        
        .info-panel {
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #4b6cb7;
        }
        
        .info-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #2c3e50;
            font-size: 16px;
        }
        
        .info-content {
            font-size: 14px;
            color: #555;
            line-height: 1.5;
        }
        
        .real-time-data {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        .data-item {
            padding: 10px;
            background-color: white;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .data-label {
            font-size: 12px;
            color: #7f8c8d;
            margin-bottom: 4px;
        }
        
        .data-value {
            font-size: 16px;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .critical-condition {
            background-color: #fff9e6;
            border-left-color: #f1c40f;
            margin-top: 10px;
            padding: 10px;
            font-size: 14px;
            color: #8e6c0a;
        }
        
        .time-control {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        
        .time-label {
            font-weight: bold;
            color: #2c3e50;
            white-space: nowrap;
        }
        
        #timeSlider {
            flex: 1;
        }
        
        .current-time {
            font-weight: bold;
            color: #4b6cb7;
            min-width: 70px;
        }
        
        .preset-scenarios {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .preset-btn {
            background-color: #ecf0f1;
            color: #2c3e50;
            padding: 8px;
            font-size: 13px;
            min-width: auto;
        }
        
        .preset-btn:hover {
            background-color: #d5dbdb;
        }
        
        footer {
            text-align: center;
            padding: 15px;
            font-size: 14px;
            color: #7f8c8d;
            border-top: 1px solid #eee;
            background-color: #f9fafc;
        }
        
        .velocity-display {
            position: absolute;
            font-size: 12px;
            font-weight: bold;
            color: white;
            background-color: rgba(0,0,0,0.7);
            padding: 2px 6px;
            border-radius: 3px;
            pointer-events: none;
        }
        
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 10px;
            font-size: 12px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .brake-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: #e74c3c;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
        }
        
        .brake-light {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #e74c3c;
            animation: brakeLight 1s infinite alternate;
        }
        
        @keyframes brakeLight {
            from { opacity: 0.3; }
            to { opacity: 1; }
        }
        
        /* å¤šè¿‡ç¨‹æ¨¡å¼æ ·å¼ */
        .process-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .process-tabs {
            display: flex;
            gap: 5px;
            overflow-x: auto;
            padding-bottom: 5px;
        }
        
        .process-tab {
            padding: 8px 15px;
            background-color: #ecf0f1;
            border-radius: 6px;
            cursor: pointer;
            white-space: nowrap;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .process-tab:hover {
            background-color: #d5dbdb;
        }
        
        .process-tab.active {
            background-color: #4b6cb7;
            color: white;
        }
        
        .process-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .process-info {
            font-size: 13px;
            color: #7f8c8d;
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 6px;
        }
        
        .mode-switcher {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            background-color: #ecf0f1;
            padding: 8px;
            border-radius: 8px;
        }
        
        .mode-btn {
            flex: 1;
            padding: 10px;
            text-align: center;
            background-color: #bdc3c7;
            color: #2c3e50;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .mode-btn.active {
            background-color: #3498db;
            color: white;
        }
        
        .mode-btn:hover {
            background-color: #95a5a6;
        }
        
        .process-time {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .process-time-label {
            font-size: 14px;
            color: #2c3e50;
            font-weight: bold;
            white-space: nowrap;
        }
        
        .process-duration {
            flex: 1;
        }
        
        .process-duration-display {
            min-width: 60px;
            text-align: center;
            font-weight: bold;
            color: #4b6cb7;
        }
        
        .process-markers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .process-marker {
            position: absolute;
            top: 10px;
            transform: translateX(-50%);
            font-size: 12px;
            color: #7f8c8d;
            font-weight: bold;
        }
        
        .process-marker-line {
            position: absolute;
            top: 30px;
            bottom: 0;
            width: 1px;
            background-color: rgba(127, 140, 141, 0.3);
        }
        
        @media (max-width: 1600px) {
            body {
                min-width: auto;
            }
            
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .charts-section {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        @media (max-width: 1200px) {
            .charts-section {
                grid-template-columns: 1fr;
            }
        }
        
        .initial-position-note {
            font-size: 12px;
            color: #7f8c8d;
            margin-top: 5px;
            font-style: italic;
        }
        
        /* è§†å›¾æ§åˆ¶æ ·å¼ */
        .view-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }
        
        .view-controls select {
            flex: 1;
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            font-size: 14px;
        }
        
        .view-controls select:focus {
            outline: none;
            border-color: #4b6cb7;
            box-shadow: 0 0 0 2px rgba(75, 108, 183, 0.2);
        }
        
        .scale-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            color: #7f8c8d;
            border: 1px solid #e0e0e0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>é«˜ä¸­ç‰©ç†AIæƒ…å¢ƒæ¢ç©¶å¹³å°</h1>
            <p class="subtitle">è¿½åŠç›¸é‡é—®é¢˜åŠ¨æ€ç”Ÿæˆç³»ç»Ÿ - æ‰©å±•ä½ç§»èŒƒå›´ç‰ˆæœ¬</p>
        </header>
        
        <div class="main-content">
            <div class="left-panel">
                <div class="mode-switcher">
                    <div class="mode-btn active" id="singleModeBtn" onclick="switchMode('single')">
                        å•è¿‡ç¨‹æ¨¡å¼
                    </div>
                    <div class="mode-btn" id="multiModeBtn" onclick="switchMode('multi')">
                        å¤šè¿‡ç¨‹æ¨¡å¼
                    </div>
                </div>
                
                <!-- å•è¿‡ç¨‹æ¨¡å¼æ§åˆ¶é¢æ¿ -->
                <div class="section" id="singleModePanel">
                    <h2 class="section-title">æ§åˆ¶é¢æ¿</h2>
                    
                    <div class="object-controls">
                        <div class="object-panel object-a">
                            <div class="object-title">
                                ğŸš— ç‰©ä½“A (è“è‰²)
                                <span id="statusA" class="object-status status-moving">è¿åŠ¨</span>
                            </div>
                            
                            <div class="control-group">
                                <label class="control-label">åˆå§‹ä½ç½® xâ‚€ (m):</label>
                                <div class="number-input-container">
                                    <input type="number" id="x0AInput" class="number-input" min="-200" max="400" value="0" step="1">
                                    <div class="input-buttons">
                                        <div class="input-btn up" onclick="changeValue('x0A', 1)">+</div>
                                        <div class="input-btn down" onclick="changeValue('x0A', -1)">-</div>
                                    </div>
                                </div>
                                <input type="range" id="x0A" min="-200" max="400" value="0" step="1">
                            </div>
                            
                            <div class="control-group">
                                <label class="control-label">åˆé€Ÿåº¦ vâ‚€ (m/s):</label>
                                <div class="number-input-container">
                                    <input type="number" id="v0AInput" class="number-input" min="0" max="50" value="10" step="0.5">
                                    <div class="input-buttons">
                                        <div class="input-btn up" onclick="changeValue('v0A', 0.5)">+</div>
                                        <div class="input-btn down" onclick="changeValue('v0A', -0.5)">-</div>
                                    </div>
                                </div>
                                <input type="range" id="v0A" min="0" max="50" value="10" step="0.5">
                            </div>
                            
                            <div class="control-group">
                                <label class="control-label">åŠ é€Ÿåº¦ a (m/sÂ²):</label>
                                <div class="number-input-container">
                                    <input type="number" id="aAInput" class="number-input" min="-5" max="5" value="0" step="0.1">
                                    <div class="input-buttons">
                                        <div class="input-btn up" onclick="changeValue('aA', 0.1)">+</div>
                                        <div class="input-btn down" onclick="changeValue('aA', -0.1)">-</div>
                                    </div>
                                </div>
                                <input type="range" id="aA" min="-5" max="5" value="0" step="0.1">
                            </div>
                            
                            <div class="control-group">
                                <label class="control-label">åˆ¹è½¦æ¨¡å¼:</label>
                                <div class="checkbox-label">
                                    <input type="checkbox" id="brakeA"> å¯ç”¨åˆ¹è½¦ï¼ˆé€Ÿåº¦å‡ä¸º0å³åœæ­¢ï¼‰
                                </div>
                            </div>
                        </div>
                        
                        <div class="object-panel object-b">
                            <div class="object-title">
                                ğŸš™ ç‰©ä½“B (çº¢è‰²)
                                <span id="statusB" class="object-status status-moving">è¿åŠ¨</span>
                            </div>
                            
                            <div class="control-group">
                                <label class="control-label">åˆå§‹ä½ç½® xâ‚€ (m):</label>
                                <div class="number-input-container">
                                    <input type="number" id="x0BInput" class="number-input" min="-200" max="400" value="30" step="1">
                                    <div class="input-buttons">
                                        <div class="input-btn up" onclick="changeValue('x0B', 1)">+</div>
                                        <div class="input-btn down" onclick="changeValue('x0B', -1)">-</div>
                                    </div>
                                </div>
                                <input type="range" id="x0B" min="-200" max="400" value="30" step="1">
                            </div>
                            
                            <div class="control-group">
                                <label class="control-label">åˆé€Ÿåº¦ vâ‚€ (m/s):</label>
                                <div class="number-input-container">
                                    <input type="number" id="v0BInput" class="number-input" min="0" max="50" value="5" step="0.5">
                                    <div class="input-buttons">
                                        <div class="input-btn up" onclick="changeValue('v0B', 0.5)">+</div>
                                        <div class="input-btn down" onclick="changeValue('v0B', -0.5)">-</div>
                                    </div>
                                </div>
                                <input type="range" id="v0B" min="0" max="50" value="5" step="0.5">
                            </div>
                            
                            <div class="control-group">
                                <label class="control-label">åŠ é€Ÿåº¦ a (m/sÂ²):</label>
                                <div class="number-input-container">
                                    <input type="number" id="aBInput" class="number-input" min="-5" max="5" value="0" step="0.1">
                                    <div class="input-buttons">
                                        <div class="input-btn up" onclick="changeValue('aB', 0.1)">+</div>
                                        <div class="input-btn down" onclick="changeValue('aB', -0.1)">-</div>
                                    </div>
                                </div>
                                <input type="range" id="aB" min="-5" max="5" value="0" step="0.1">
                            </div>
                            
                            <div class="control-group">
                                <label class="control-label">åˆ¹è½¦æ¨¡å¼:</label>
                                <div class="checkbox-label">
                                    <input type="checkbox" id="brakeB"> å¯ç”¨åˆ¹è½¦ï¼ˆé€Ÿåº¦å‡ä¸º0å³åœæ­¢ï¼‰
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="time-control">
                        <div class="time-label">æ—¶é—´ t (s):</div>
                        <input type="range" id="timeSlider" min="0" max="50" value="0" step="0.1">
                        <div class="number-input-container" style="min-width: 100px;">
                            <input type="number" id="timeInput" class="number-input" min="0" max="50" value="0" step="0.1">
                        </div>
                    </div>
                </div>
                
                <!-- å¤šè¿‡ç¨‹æ¨¡å¼æ§åˆ¶é¢æ¿ -->
                <div class="section" id="multiModePanel" style="display: none;">
                    <h2 class="section-title">
                        å¤šè¿‡ç¨‹æ§åˆ¶é¢æ¿
                        <span style="font-size: 12px; color: #7f8c8d;">å½“å‰è¿‡ç¨‹: <span id="currentProcessIndex">1</span>/<span id="totalProcesses">1</span></span>
                    </h2>
                    
                    <div class="process-controls">
                        <div class="process-tabs" id="processTabs">
                            <div class="process-tab active" onclick="switchProcess(0)">è¿‡ç¨‹ 1</div>
                        </div>
                        
                        <div class="process-time">
                            <div class="process-time-label">æŒç»­æ—¶é—´:</div>
                            <input type="range" id="processDuration" min="1" max="30" value="10" step="0.5" class="process-duration">
                            <div class="number-input-container" style="min-width: 80px;">
                                <input type="number" id="processDurationInput" class="number-input" min="1" max="30" value="10" step="0.5">
                                <span style="font-size: 12px; color: #7f8c8d;">s</span>
                            </div>
                        </div>
                        
                        <div class="object-controls">
                            <div class="object-panel object-a">
                                <div class="object-title">
                                    ğŸš— ç‰©ä½“A (è“è‰²)
                                </div>
                                
                                <!-- åˆå§‹ä½ç½®ï¼ˆä»…è¿‡ç¨‹1æ˜¾ç¤ºï¼‰ -->
                                <div class="control-group" id="multiX0AGroup">
                                    <label class="control-label">åˆå§‹ä½ç½® xâ‚€ (m):</label>
                                    <div class="number-input-container">
                                        <input type="number" id="multiX0AInput" class="number-input" min="-200" max="400" value="0" step="1">
                                        <div class="input-buttons">
                                            <div class="input-btn up" onclick="changeMultiValue('x0A', 1)">+</div>
                                            <div class="input-btn down" onclick="changeMultiValue('x0A', -1)">-</div>
                                        </div>
                                    </div>
                                    <input type="range" id="multiX0A" min="-200" max="400" value="0" step="1">
                                    <div class="initial-position-note" id="multiX0ANote">ä»…è¿‡ç¨‹1å¯è®¾ç½®åˆå§‹ä½ç½®</div>
                                </div>
                                
                                <div class="control-group">
                                    <label class="control-label">åˆé€Ÿåº¦ vâ‚€ (m/s):</label>
                                    <div class="number-input-container">
                                        <input type="number" id="multiV0AInput" class="number-input" min="0" max="50" value="10" step="0.5">
                                        <div class="input-buttons">
                                            <div class="input-btn up" onclick="changeMultiValue('v0A', 0.5)">+</div>
                                            <div class="input-btn down" onclick="changeMultiValue('v0A', -0.5)">-</div>
                                        </div>
                                    </div>
                                    <input type="range" id="multiV0A" min="0" max="50" value="10" step="0.5">
                                    <div class="initial-position-note" id="multiV0ANote">è¿‡ç¨‹1çš„åˆé€Ÿåº¦ï¼Œåç»­è¿‡ç¨‹ç»§æ‰¿ä¸Šä¸€è¿‡ç¨‹æœ«é€Ÿåº¦</div>
                                </div>
                                
                                <div class="control-group">
                                    <label class="control-label">åŠ é€Ÿåº¦ a (m/sÂ²):</label>
                                    <div class="number-input-container">
                                        <input type="number" id="multiAAInput" class="number-input" min="-5" max="5" value="0" step="0.1">
                                        <div class="input-buttons">
                                            <div class="input-btn up" onclick="changeMultiValue('aA', 0.1)">+</div>
                                            <div class="input-btn down" onclick="changeMultiValue('aA', -0.1)">-</div>
                                        </div>
                                    </div>
                                    <input type="range" id="multiAA" min="-5" max="5" value="0" step="0.1">
                                </div>
                                
                                <div class="control-group">
                                    <label class="control-label">åˆ¹è½¦æ¨¡å¼:</label>
                                    <div class="checkbox-label">
                                        <input type="checkbox" id="multiBrakeA"> å¯ç”¨åˆ¹è½¦ï¼ˆé€Ÿåº¦å‡ä¸º0å³åœæ­¢ï¼‰
                                    </div>
                                </div>
                            </div>
                            
                            <div class="object-panel object-b">
                                <div class="object-title">
                                    ğŸš™ ç‰©ä½“B (çº¢è‰²)
                                </div>
                                
                                <!-- åˆå§‹ä½ç½®ï¼ˆä»…è¿‡ç¨‹1æ˜¾ç¤ºï¼‰ -->
                                <div class="control-group" id="multiX0BGroup">
                                    <label class="control-label">åˆå§‹ä½ç½® xâ‚€ (m):</label>
                                    <div class="number-input-container">
                                        <input type="number" id="multiX0BInput" class="number-input" min="-200" max="400" value="30" step="1">
                                        <div class="input-buttons">
                                            <div class="input-btn up" onclick="changeMultiValue('x0B', 1)">+</div>
                                            <div class="input-btn down" onclick="changeMultiValue('x0B', -1)">-</div>
                                        </div>
                                    </div>
                                    <input type="range" id="multiX0B" min="-200" max="400" value="30" step="1">
                                    <div class="initial-position-note" id="multiX0BNote">ä»…è¿‡ç¨‹1å¯è®¾ç½®åˆå§‹ä½ç½®</div>
                                </div>
                                
                                <div class="control-group">
                                    <label class="control-label">åˆé€Ÿåº¦ vâ‚€ (m/s):</label>
                                    <div class="number-input-container">
                                        <input type="number" id="multiV0BInput" class="number-input" min="0" max="50" value="5" step="0.5">
                                        <div class="input-buttons">
                                            <div class="input-btn up" onclick="changeMultiValue('v0B', 0.5)">+</div>
                                            <div class="input-btn down" onclick="changeMultiValue('v0B', -0.5)">-</div>
                                        </div>
                                    </div>
                                    <input type="range" id="multiV0B" min="0" max="50" value="5" step="0.5">
                                    <div class="initial-position-note" id="multiV0BNote">è¿‡ç¨‹1çš„åˆé€Ÿåº¦ï¼Œåç»­è¿‡ç¨‹ç»§æ‰¿ä¸Šä¸€è¿‡ç¨‹æœ«é€Ÿåº¦</div>
                                </div>
                                
                                <div class="control-group">
                                    <label class="control-label">åŠ é€Ÿåº¦ a (m/sÂ²):</label>
                                    <div class="number-input-container">
                                        <input type="number" id="multiABInput" class="number-input" min="-5" max="5" value="0" step="0.1">
                                        <div class="input-buttons">
                                            <div class="input-btn up" onclick="changeMultiValue('aB', 0.1)">+</div>
                                            <div class="input-btn down" onclick="changeMultiValue('aB', -0.1)">-</div>
                                        </div>
                                    </div>
                                    <input type="range" id="multiAB" min="-5" max="5" value="0" step="0.1">
                                </div>
                                
                                <div class="control-group">
                                    <label class="control-label">åˆ¹è½¦æ¨¡å¼:</label>
                                    <div class="checkbox-label">
                                        <input type="checkbox" id="multiBrakeB"> å¯ç”¨åˆ¹è½¦ï¼ˆé€Ÿåº¦å‡ä¸º0å³åœæ­¢ï¼‰
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="process-actions">
                            <button class="secondary" onclick="addProcess()">+ æ·»åŠ è¿‡ç¨‹</button>
                            <button class="secondary" onclick="removeProcess()" id="removeProcessBtn" disabled>- åˆ é™¤è¿‡ç¨‹</button>
                            <button class="secondary" onclick="resetMultiProcess()">â†º é‡ç½®æ‰€æœ‰</button>
                        </div>
                        
                        <div class="process-info">
                            <strong>å¤šè¿‡ç¨‹æ¨¡å¼è¯´æ˜:</strong><br>
                            1. æ¯ä¸ªè¿‡ç¨‹æœ‰ç‹¬ç«‹çš„è¿åŠ¨å‚æ•°å’ŒæŒç»­æ—¶é—´<br>
                            2. è¿‡ç¨‹1å¯è®¾ç½®åˆå§‹ä½ç½®å’Œåˆé€Ÿåº¦ï¼Œåç»­è¿‡ç¨‹ç»§æ‰¿ä¸Šä¸€ä¸ªè¿‡ç¨‹çš„æœ«çŠ¶æ€<br>
                            3. æ€»è¿åŠ¨æ—¶é—´ = æ‰€æœ‰è¿‡ç¨‹æŒç»­æ—¶é—´ä¹‹å’Œ<br>
                            4. å¯ä»¥æ·»åŠ æœ€å¤š5ä¸ªè¿‡ç¨‹
                        </div>
                    </div>
                </div>
                
                <!-- è§†å›¾æ§åˆ¶éƒ¨åˆ† -->
                <div class="section">
                    <h2 class="section-title">è§†å›¾æ§åˆ¶</h2>
                    
                    <div class="buttons" style="margin-bottom: 10px;">
                        <button id="zoomInBtn" class="secondary" title="æ”¾å¤§è§†å›¾">ğŸ” æ”¾å¤§</button>
                        <button id="zoomOutBtn" class="secondary" title="ç¼©å°è§†å›¾">ğŸ” ç¼©å°</button>
                        <button id="zoomFitBtn" class="secondary" title="é€‚åˆè§†å›¾">ğŸ“ é€‚åˆè§†å›¾</button>
                        <button id="resetViewBtn" class="secondary" title="é‡ç½®è§†å›¾">â†º é‡ç½®è§†å›¾</button>
                    </div>
                    
                    <div class="view-controls">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <label style="font-size: 14px; color: #555;">æ˜¾ç¤ºæ¨¡å¼:</label>
                            <select id="viewRangeSelect">
                                <option value="auto">è‡ªåŠ¨è°ƒæ•´</option>
                                <option value="fixed">å›ºå®šèŒƒå›´ (-50~150m)</option>
                                <option value="followCurrent">è·Ÿéšå½“å‰ä½ç½®</option>
                                <option value="showAll">æ˜¾ç¤ºæ‰€æœ‰å†…å®¹</option>
                                <option value="largeDisplacement">å¤§ä½ç§»æ¨¡å¼</option>
                            </select>
                        </div>
                        
                        <div style="font-size: 13px; color: #7f8c8d; padding: 8px; background-color: #f8f9fa; border-radius: 6px;">
                            <strong>è§†å›¾ä¿¡æ¯:</strong> 
                            <span id="viewInfo">èŒƒå›´: -50m ~ 150m (200m)</span>
                            <br>
                            <span id="scaleInfo">æ¯”ä¾‹å°º: 1:20</span>
                        </div>
                    </div>
                    
                    <div style="font-size: 12px; color: #95a5a6; margin-top: 10px;">
                        <strong>æ“ä½œæç¤º:</strong>
                        <ul style="margin-left: 15px; margin-top: 5px;">
                            <li>é¼ æ ‡æ»šè½®: ç¼©æ”¾è§†å›¾</li>
                            <li>é¼ æ ‡æ‹–æ‹½: å¹³ç§»è§†å›¾</li>
                            <li>åŒå‡»ç‰©ä½“: å±…ä¸­æ˜¾ç¤ºè¯¥ç‰©ä½“</li>
                        </ul>
                    </div>
                </div>
                
                <div class="info-panel">
                    <div class="info-title">ğŸ“Š å®æ—¶æ•°æ®</div>
                    <div class="real-time-data">
                        <div class="data-item">
                            <div class="data-label">ä¸¤è½¦è·ç¦»</div>
                            <div id="distanceValue" class="data-value">30.0 m</div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">ç›¸å¯¹é€Ÿåº¦</div>
                            <div id="relativeSpeedValue" class="data-value">5.0 m/s</div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Aè½¦é€Ÿåº¦</div>
                            <div id="velocityAValue" class="data-value">10.0 m/s</div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Bè½¦é€Ÿåº¦</div>
                            <div id="velocityBValue" class="data-value">5.0 m/s</div>
                        </div>
                    </div>
                    
                    <div class="real-time-data" style="margin-top: 10px;">
                        <div class="data-item">
                            <div class="data-label">Aè½¦ä½ç§»</div>
                            <div id="displacementAValue" class="data-value">0.0 m</div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Bè½¦ä½ç§»</div>
                            <div id="displacementBValue" class="data-value">0.0 m</div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Aè½¦è¿åŠ¨æ—¶é—´</div>
                            <div id="movementTimeAValue" class="data-value">0.0 s</div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Bè½¦è¿åŠ¨æ—¶é—´</div>
                            <div id="movementTimeBValue" class="data-value">0.0 s</div>
                        </div>
                    </div>
                    
                    <div class="real-time-data" style="margin-top: 10px;">
                        <div class="data-item">
                            <div class="data-label">Aè½¦åŠ é€Ÿåº¦</div>
                            <div id="accelerationAValue" class="data-value">0.0 m/sÂ²</div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">Bè½¦åŠ é€Ÿåº¦</div>
                            <div id="accelerationBValue" class="data-value">0.0 m/sÂ²</div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">å½“å‰è¿‡ç¨‹</div>
                            <div id="currentProcessValue" class="data-value">1</div>
                        </div>
                        <div class="data-item">
                            <div class="data-label">è¿‡ç¨‹æ—¶é—´</div>
                            <div id="processTimeValue" class="data-value">0.0 s</div>
                        </div>
                    </div>
                    
                    <div id="criticalInfo" class="critical-condition" style="display: none; margin-top: 15px;">
                        âš  <span id="criticalText"></span>
                    </div>
                    
                    <div id="largeDisplacementWarning" class="critical-condition" style="display: none; margin-top: 10px; background-color: rgba(241, 196, 15, 0.1);">
                        âš  <span id="largeDisplacementText"></span>
                    </div>
                </div>
                
                <div class="section">
                    <h2 class="section-title">æ§åˆ¶æŒ‰é’®</h2>
                    <div class="buttons">
                        <button id="playBtn" class="play">â–¶ æ’­æ”¾</button>
                        <button id="pauseBtn" class="pause" disabled>â¸ æš‚åœ</button>
                        <button id="resetBtn" class="reset">â†º é‡ç½®</button>
                        <button id="toStartBtn" class="secondary">â® å›åˆ°èµ·ç‚¹</button>
                        <button id="randomBtn">ğŸ² éšæœºç”Ÿæˆ</button>
                    </div>
                    
                    <div class="checkbox-group">
                        <label class="checkbox-label">
                            <input type="checkbox" id="showAllMoments" checked> æ˜¾ç¤ºå…³é”®æ—¶åˆ»
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="showVelocity" checked> æ˜¾ç¤ºå®æ—¶é€Ÿåº¦
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="showTrajectory" checked> æ˜¾ç¤ºè¿åŠ¨è½¨è¿¹
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="showStopPosition" checked> æ˜¾ç¤ºåœè½¦ä½ç½®
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="showBrakeLight" checked> æ˜¾ç¤ºåˆ¹è½¦ç¯
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="showProcessMarkers" checked> æ˜¾ç¤ºè¿‡ç¨‹æ ‡è®°
                        </label>
                        <label class="checkbox-label">
                            <input type="checkbox" id="showScaleIndicator" checked> æ˜¾ç¤ºæ¯”ä¾‹å°º
                        </label>
                    </div>
                    
                    <div class="preset-scenarios">
                        <h3 style="grid-column: span 2; margin-top: 15px; color: #2c3e50; font-size: 16px;">é¢„è®¾åœºæ™¯</h3>
                        <button class="preset-btn" onclick="setPreset('chase')">åŒ€é€Ÿè¿½åŒ€é€Ÿ</button>
                        <button class="preset-btn" onclick="setPreset('accelerateChase')">åŒ€åŠ é€Ÿè¿½åŒ€é€Ÿ</button>
                        <button class="preset-btn" onclick="setPreset('decelerateChase')">åŒ€å‡é€Ÿè¿½åŒ€é€Ÿ</button>
                        <button class="preset-btn" onclick="setPreset('rearBrake')">åè½¦åˆ¹è½¦é—®é¢˜</button>
                        <button class="preset-btn" onclick="setPreset('bothBrake')">ä¸¤è½¦åŒæ—¶åˆ¹è½¦</button>
                        <button class="preset-btn" onclick="setPreset('cannotCatch')">æ°¸è¿œè¿½ä¸ä¸Š</button>
                        <button class="preset-btn" onclick="setPreset('meetAfterBrake')">åˆ¹è½¦åç›¸é‡</button>
                        <button class="preset-btn" onclick="setPreset('largeDisplacement')">å¤§ä½ç§»æ¼”ç¤º</button>
                        <button class="preset-btn" onclick="setPreset('multiProcessDemo')">å¤šè¿‡ç¨‹æ¼”ç¤º</button>
                    </div>
                </div>
            </div>
            
            <div class="right-panel">
                <div class="motion-section">
                    <div class="section">
                        <h2 class="section-title">
                            ğŸš€ è¿åŠ¨è¿‡ç¨‹è§†å›¾
                            <div class="legend">
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #3498db;"></div>
                                    <span>ç‰©ä½“A</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #e74c3c;"></div>
                                    <span>ç‰©ä½“B</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #2ecc71;"></div>
                                    <span>åˆå§‹æ—¶åˆ»</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #9b59b6;"></div>
                                    <span>ç›¸é‡æ—¶åˆ»</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #f1c40f;"></div>
                                    <span>è·ç¦»æå€¼</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background-color: #e74c3c;"></div>
                                    <span>åœè½¦æ—¶åˆ»</span>
                                </div>
                            </div>
                        </h2>
                        <div style="position: relative;">
                            <canvas id="motionCanvas" width="800" height="300"></canvas>
                            <div id="processMarkers" class="process-markers"></div>
                            <div id="scaleIndicator" class="scale-indicator"></div>
                        </div>
                    </div>
                    
                    <div class="special-moments">
                        <h2 class="section-title">â° å…³é”®æ—¶åˆ»</h2>
                        <div id="momentsList" class="moment-list">
                            <!-- å…³é”®æ—¶åˆ»åˆ—è¡¨ä¼šåŠ¨æ€ç”Ÿæˆ -->
                        </div>
                    </div>
                </div>
                
                <div class="charts-section">
                    <div class="section">
                        <h2 class="section-title">ğŸ“ˆ ä½ç§»-æ—¶é—´å›¾ (s-t)</h2>
                        <div id="sChart" class="chart-container"></div>
                    </div>
                    
                    <div class="section">
                        <h2 class="section-title">ğŸ“Š é€Ÿåº¦-æ—¶é—´å›¾ (v-t)</h2>
                        <div id="vChart" class="chart-container"></div>
                    </div>
                    
                    <div class="section">
                        <h2 class="section-title">ğŸ“‰ åŠ é€Ÿåº¦-æ—¶é—´å›¾ (a-t)</h2>
                        <div id="aChart" class="chart-container"></div>
                    </div>
                    
                    <div class="section">
                        <h2 class="section-title">ğŸ“ è·ç¦»-æ—¶é—´å›¾ (d-t)</h2>
                        <div id="dChart" class="chart-container"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <footer>
            <p>Â© 2025 é«˜ä¸­ç‰©ç†æ•™å­¦å·¥å…· - å¤šè¿‡ç¨‹è¿½åŠç›¸é‡ä¸åˆ¹è½¦é—®é¢˜æ¨¡æ‹Ÿå™¨ - æ‰©å±•ä½ç§»èŒƒå›´ç‰ˆæœ¬</p>
            <p>è®¾è®¡åŸç†: x = xâ‚€ + vâ‚€Â·t + Â½Â·aÂ·tÂ² (å½“vâ‰¥0) | åˆ¹è½¦æ¨¡å¼: é€Ÿåº¦å‡ä¸º0å³åœæ­¢è¿åŠ¨ | æ”¯æŒå•è¿‡ç¨‹å’Œå¤šè¿‡ç¨‹æ¨¡å¼ | æ”¯æŒå¤§ä½ç§»æ˜¾ç¤º</p>
        </footer>
    </div>

    <script>
        // ==================== å…¨å±€å˜é‡ä¸æ•°æ®ç»“æ„ ====================
        // å•è¿‡ç¨‹æ¨¡å¼å‚æ•°
        let singleParams = {
            x0A: 0,    // Aåˆå§‹ä½ç½® (m)
            v0A: 10,   // Aåˆé€Ÿåº¦ (m/s)
            aA: 0,     // AåŠ é€Ÿåº¦ (m/sÂ²)
            x0B: 30,   // Båˆå§‹ä½ç½® (m)
            v0B: 5,    // Båˆé€Ÿåº¦ (m/s)
            aB: 0,     // BåŠ é€Ÿåº¦ (m/sÂ²)
            t: 0,      // å½“å‰æ—¶é—´ (s)
            maxT: 50   // æœ€å¤§æ—¶é—´ (s) - æ‰©å±•ä¸º50ç§’
        };
        
        // å¤šè¿‡ç¨‹æ¨¡å¼æ•°æ®ç»“æ„
        let multiProcesses = [
            {
                duration: 10,     // è¿‡ç¨‹æŒç»­æ—¶é—´ (s)
                params: {
                    x0A: 0,       // Aåˆå§‹ä½ç½® (m) - ä»…è¿‡ç¨‹1æœ‰æ•ˆ
                    x0B: 30,      // Båˆå§‹ä½ç½® (m) - ä»…è¿‡ç¨‹1æœ‰æ•ˆ
                    v0A: 10,      // Aåˆé€Ÿåº¦ (m/s)
                    aA: 0,        // AåŠ é€Ÿåº¦ (m/sÂ²)
                    v0B: 5,       // Båˆé€Ÿåº¦ (m/s)
                    aB: 0,        // BåŠ é€Ÿåº¦ (m/sÂ²)
                    brakeA: false, // Aåˆ¹è½¦æ¨¡å¼
                    brakeB: false  // Båˆ¹è½¦æ¨¡å¼
                }
            }
        ];
        
        let currentProcessIndex = 0; // å½“å‰ç¼–è¾‘çš„è¿‡ç¨‹ç´¢å¼•
        let currentMode = 'single'; // å½“å‰æ¨¡å¼: 'single' æˆ– 'multi'
        
        // ç‰©ä½“çŠ¶æ€
        let objectStates = {
            A: { isMoving: true, stopTime: null, stopPosition: null, movementTime: 0 },
            B: { isMoving: true, stopTime: null, stopPosition: null, movementTime: 0 }
        };
        
        // è¿‡ç¨‹çŠ¶æ€
        let processStates = []; // æ¯ä¸ªè¿‡ç¨‹çš„å¼€å§‹æ—¶é—´ã€ç»“æŸæ—¶é—´ã€çŠ¶æ€
        
        // åŠ¨ç”»æ§åˆ¶
        let animationId = null;
        let isPlaying = false;
        let animationSpeed = 1.0;
        let lastTimestamp = 0;
        
        // å…³é”®æ—¶åˆ»æ•°æ®
        let specialMoments = [];
        
        // ==================== è§†å›¾æ§åˆ¶å˜é‡ ====================
        let viewMode = 'auto';  // 'auto', 'fixed', 'followCurrent', 'showAll', 'largeDisplacement'
        let zoomLevel = 1.0;    // ç¼©æ”¾çº§åˆ« (1.0 = 200ç±³èŒƒå›´)
        let viewCenter = 0;     // è§†å›¾ä¸­å¿ƒä½ç½® (ç±³)
        let isDragging = false; // æ˜¯å¦æ­£åœ¨æ‹–æ‹½
        let lastMouseX = 0;     // ä¸Šæ¬¡é¼ æ ‡Xä½ç½®
        let lastMouseY = 0;     // ä¸Šæ¬¡é¼ æ ‡Yä½ç½®
        
        // é¼ æ ‡æ»šè½®ç¼©æ”¾çµæ•åº¦
        const ZOOM_SENSITIVITY = 0.001;
        
        // ==================== DOMå…ƒç´  ====================
        const canvas = document.getElementById('motionCanvas');
        const ctx = canvas.getContext('2d');
        
        // æ¨¡å¼åˆ‡æ¢
        const singleModeBtn = document.getElementById('singleModeBtn');
        const multiModeBtn = document.getElementById('multiModeBtn');
        const singleModePanel = document.getElementById('singleModePanel');
        const multiModePanel = document.getElementById('multiModePanel');
        
        // å•è¿‡ç¨‹è¾“å…¥æ§ä»¶
        const singleInputs = {
            x0A: document.getElementById('x0AInput'),
            v0A: document.getElementById('v0AInput'),
            aA: document.getElementById('aAInput'),
            x0B: document.getElementById('x0BInput'),
            v0B: document.getElementById('v0BInput'),
            aB: document.getElementById('aBInput'),
            time: document.getElementById('timeInput')
        };
        
        const singleSliders = {
            x0A: document.getElementById('x0A'),
            v0A: document.getElementById('v0A'),
            aA: document.getElementById('aA'),
            x0B: document.getElementById('x0B'),
            v0B: document.getElementById('v0B'),
            aB: document.getElementById('aB'),
            time: document.getElementById('timeSlider')
        };
        
        // å¤šè¿‡ç¨‹è¾“å…¥æ§ä»¶
        const multiInputs = {
            x0A: document.getElementById('multiX0AInput'),
            v0A: document.getElementById('multiV0AInput'),
            aA: document.getElementById('multiAAInput'),
            x0B: document.getElementById('multiX0BInput'),
            v0B: document.getElementById('multiV0BInput'),
            aB: document.getElementById('multiABInput'),
            duration: document.getElementById('processDurationInput')
        };
        
        const multiSliders = {
            x0A: document.getElementById('multiX0A'),
            v0A: document.getElementById('multiV0A'),
            aA: document.getElementById('multiAA'),
            x0B: document.getElementById('multiX0B'),
            v0B: document.getElementById('multiV0B'),
            aB: document.getElementById('multiAB'),
            duration: document.getElementById('processDuration')
        };
        
        // å¤šè¿‡ç¨‹å…ƒç´ 
        const processTabs = document.getElementById('processTabs');
        const currentProcessIndexSpan = document.getElementById('currentProcessIndex');
        const totalProcessesSpan = document.getElementById('totalProcesses');
        const removeProcessBtn = document.getElementById('removeProcessBtn');
        
        // å¤é€‰æ¡†
        const brakeA = document.getElementById('brakeA');
        const brakeB = document.getElementById('brakeB');
        const multiBrakeA = document.getElementById('multiBrakeA');
        const multiBrakeB = document.getElementById('multiBrakeB');
        
        // æŒ‰é’®
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn');
        const toStartBtn = document.getElementById('toStartBtn');
        const randomBtn = document.getElementById('randomBtn');
        
        // è§†å›¾æ§åˆ¶æŒ‰é’®
        const zoomInBtn = document.getElementById('zoomInBtn');
        const zoomOutBtn = document.getElementById('zoomOutBtn');
        const zoomFitBtn = document.getElementById('zoomFitBtn');
        const resetViewBtn = document.getElementById('resetViewBtn');
        const viewRangeSelect = document.getElementById('viewRangeSelect');
        
        // çŠ¶æ€æ˜¾ç¤º
        const statusA = document.getElementById('statusA');
        const statusB = document.getElementById('statusB');
        
        // å…³é”®æ—¶åˆ»åˆ—è¡¨
        const momentsList = document.getElementById('momentsList');
        
        // è¿‡ç¨‹æ ‡è®°å®¹å™¨
        const processMarkers = document.getElementById('processMarkers');
        
        // æ¯”ä¾‹å°ºæŒ‡ç¤ºå™¨
        const scaleIndicator = document.getElementById('scaleIndicator');
        
        // è­¦å‘Šå…ƒç´ 
        const largeDisplacementWarning = document.getElementById('largeDisplacementWarning');
        const largeDisplacementText = document.getElementById('largeDisplacementText');
        
        // å›¾è¡¨å®ä¾‹
        let sChart, vChart, aChart, dChart;
        
        // ==================== åˆå§‹åŒ–å‡½æ•° ====================
        
        function init() {
            console.log("åˆå§‹åŒ–...");
            
            // ç»‘å®šäº‹ä»¶
            bindEvents();
            
            // åˆå§‹åŒ–å›¾è¡¨
            initCharts();
            
            // é‡ç½®æ‰€æœ‰æ•°æ®
            resetAnimation();
            
            // æ›´æ–°è§†å›¾ä¿¡æ¯
            updateViewInfo();
            
            console.log("åˆå§‹åŒ–å®Œæˆ");
        }
        
        // ==================== è§†å›¾æ§åˆ¶å‡½æ•° ====================
        
        // è®¡ç®—è‡ªåŠ¨è°ƒæ•´çš„è§†å›¾èŒƒå›´
        function calculateAutoViewRange() {
            const t = currentMode === 'single' ? singleParams.t : singleParams.t;
            const maxT = getMaxTime();
            
            let minX = Infinity;
            let maxX = -Infinity;
            
            // æ”¶é›†æ‰€æœ‰éœ€è¦æ˜¾ç¤ºçš„ä½ç½®
            const positions = [];
            
            // å½“å‰ç‰©ä½“ä½ç½®
            const xA = calculatePosition('A', t);
            const xB = calculatePosition('B', t);
            positions.push(xA, xB);
            
            // åˆå§‹ä½ç½®
            let initialXA, initialXB;
            if (currentMode === 'single') {
                initialXA = singleParams.x0A;
                initialXB = singleParams.x0B;
            } else {
                initialXA = multiProcesses[0].params.x0A !== null ? multiProcesses[0].params.x0A : 0;
                initialXB = multiProcesses[0].params.x0B !== null ? multiProcesses[0].params.x0B : 30;
            }
            positions.push(initialXA, initialXB);
            
            // åœè½¦ä½ç½®
            if (objectStates.A.stopPosition !== null) positions.push(objectStates.A.stopPosition);
            if (objectStates.B.stopPosition !== null) positions.push(objectStates.B.stopPosition);
            
            // å…³é”®æ—¶åˆ»çš„ä½ç½®
            specialMoments.forEach(moment => {
                if (moment.time <= maxT) {
                    positions.push(
                        calculatePosition('A', moment.time),
                        calculatePosition('B', moment.time)
                    );
                }
            });
            
            // è½¨è¿¹é‡‡æ ·ç‚¹ï¼ˆç”¨äºæ˜¾ç¤ºè½¨è¿¹ï¼‰
            if (document.getElementById('showTrajectory').checked) {
                const step = maxT / 20;
                for (let time = 0; time <= maxT; time += step) {
                    positions.push(
                        calculatePosition('A', time),
                        calculatePosition('B', time)
                    );
                }
            }
            
            // è®¡ç®—æœ€å°å’Œæœ€å¤§å€¼
            positions.forEach(pos => {
                if (pos !== null && !isNaN(pos)) {
                    minX = Math.min(minX, pos);
                    maxX = Math.max(maxX, pos);
                }
            });
            
            // å¦‚æœæ²¡æœ‰æœ‰æ•ˆæ•°æ®ï¼Œä½¿ç”¨é»˜è®¤èŒƒå›´
            if (!isFinite(minX) || !isFinite(maxX)) {
                minX = -50;
                maxX = 150;
            }
            
            // ç¡®ä¿æœ€å°èŒƒå›´
            const rangeWidth = maxX - minX;
            if (rangeWidth < 20) {
                const center = (minX + maxX) / 2;
                minX = center - 10;
                maxX = center + 10;
            }
            
            // æ·»åŠ è¾¹ç•Œä½™é‡
            const margin = Math.max(20, rangeWidth * 0.1);
            minX -= margin;
            maxX += margin;
            
            // æ‰©å±•é™åˆ¶èŒƒå›´ï¼ˆæ”¯æŒæ›´å¤§ä½ç§»ï¼‰
            minX = Math.max(-2000, minX);
            maxX = Math.min(2000, maxX);
            
            // å¯¹äºéå¸¸å¤§çš„ä½ç§»ï¼Œå¯ä»¥è¿›ä¸€æ­¥æ”¾å®½é™åˆ¶
            if (maxX - minX > 1000) {
                minX = Math.max(-5000, minX);
                maxX = Math.min(5000, maxX);
            }
            
            return { minX, maxX };
        }
        
        // è®¡ç®—"æ˜¾ç¤ºæ‰€æœ‰å†…å®¹"çš„è§†å›¾èŒƒå›´
        function calculateShowAllViewRange() {
            const maxT = getMaxTime();
            
            let minX = Infinity;
            let maxX = -Infinity;
            
            // é‡‡æ ·æ—¶é—´ç‚¹
            const step = maxT / 100;
            for (let t = 0; t <= maxT; t += step) {
                const xA = calculatePosition('A', t);
                const xB = calculatePosition('B', t);
                minX = Math.min(minX, xA, xB);
                maxX = Math.max(maxX, xA, xB);
            }
            
            // æ£€æŸ¥å…³é”®æ—¶åˆ»
            specialMoments.forEach(moment => {
                const xA = calculatePosition('A', moment.time);
                const xB = calculatePosition('B', moment.time);
                minX = Math.min(minX, xA, xB);
                maxX = Math.max(maxX, xA, xB);
            });
            
            // æ£€æŸ¥åœè½¦ä½ç½®
            if (objectStates.A.stopPosition !== null) {
                minX = Math.min(minX, objectStates.A.stopPosition);
                maxX = Math.max(maxX, objectStates.A.stopPosition);
            }
            if (objectStates.B.stopPosition !== null) {
                minX = Math.min(minX, objectStates.B.stopPosition);
                maxX = Math.max(maxX, objectStates.B.stopPosition);
            }
            
            // å¦‚æœæ²¡æœ‰æœ‰æ•ˆæ•°æ®ï¼Œä½¿ç”¨é»˜è®¤èŒƒå›´
            if (!isFinite(minX) || !isFinite(maxX)) {
                minX = -50;
                maxX = 150;
            }
            
            // ç¡®ä¿æœ€å°èŒƒå›´
            const rangeWidth = maxX - minX;
            if (rangeWidth < 20) {
                const center = (minX + maxX) / 2;
                minX = center - 10;
                maxX = center + 10;
            }
            
            // æ·»åŠ è¾¹ç•Œä½™é‡
            const margin = Math.max(20, rangeWidth * 0.1);
            minX -= margin;
            maxX += margin;
            
            // æ‰©å±•é™åˆ¶èŒƒå›´
            minX = Math.max(-5000, minX);
            maxX = Math.min(5000, maxX);
            
            return { minX, maxX };
        }
        
        // æ ¹æ®å½“å‰æ¨¡å¼è·å–è§†å›¾èŒƒå›´
        function getViewRange() {
            const t = currentMode === 'single' ? singleParams.t : singleParams.t;
            
            switch (viewMode) {
                case 'fixed':
                    return { minX: -50, maxX: 150 };
                    
                case 'followCurrent':
                    const xA = calculatePosition('A', t);
                    const xB = calculatePosition('B', t);
                    const center = (xA + xB) / 2;
                    const rangeWidth = 200 / zoomLevel;
                    return {
                        minX: center - rangeWidth / 2,
                        maxX: center + rangeWidth / 2
                    };
                    
                case 'showAll':
                    const range = calculateShowAllViewRange();
                    // è°ƒæ•´ç¼©æ”¾çº§åˆ«ä»¥æ˜¾ç¤ºæ•´ä¸ªèŒƒå›´
                    const neededZoom = 200 / (range.maxX - range.minX);
                    zoomLevel = Math.max(0.1, Math.min(neededZoom, 10));
                    viewCenter = (range.minX + range.maxX) / 2;
                    return range;
                    
                case 'largeDisplacement':
                    // å¤§ä½ç§»æ¨¡å¼ï¼šæ˜¾ç¤ºæ›´å¤§çš„èŒƒå›´
                    const maxT = getMaxTime();
                    let minX = Infinity;
                    let maxX = -Infinity;
                    
                    // åªæ£€æŸ¥åˆå§‹å’Œæœ€ç»ˆä½ç½®
                    const positions = [
                        calculatePosition('A', 0),
                        calculatePosition('B', 0),
                        calculatePosition('A', maxT),
                        calculatePosition('B', maxT)
                    ];
                    
                    positions.forEach(pos => {
                        if (!isNaN(pos)) {
                            minX = Math.min(minX, pos);
                            maxX = Math.max(maxX, pos);
                        }
                    });
                    
                    // æ·»åŠ è¾ƒå¤§çš„è¾¹è·
                    const margin = Math.max(100, (maxX - minX) * 0.3);
                    minX = minX - margin;
                    maxX = maxX + margin;
                    
                    // ç¡®ä¿åœ¨åˆç†èŒƒå›´å†…
                    minX = Math.max(-10000, minX);
                    maxX = Math.min(10000, maxX);
                    
                    // è°ƒæ•´ç¼©æ”¾çº§åˆ«
                    const largeZoom = 200 / (maxX - minX);
                    zoomLevel = Math.max(0.05, Math.min(largeZoom, 10));
                    viewCenter = (minX + maxX) / 2;
                    
                    return { minX, maxX };
                    
                case 'auto':
                default:
                    const autoRange = calculateAutoViewRange();
                    // è°ƒæ•´ç¼©æ”¾çº§åˆ«ä»¥æ˜¾ç¤ºæ•´ä¸ªèŒƒå›´
                    const autoNeededZoom = 200 / (autoRange.maxX - autoRange.minX);
                    zoomLevel = Math.max(0.1, Math.min(autoNeededZoom, 10));
                    viewCenter = (autoRange.minX + autoRange.maxX) / 2;
                    return autoRange;
            }
        }
        
        // åæ ‡è½¬æ¢å‡½æ•°
        function positionToCanvasX(x) {
            const range = getViewRange();
            const width = canvas.width;
            
            // ç¡®ä¿xåœ¨èŒƒå›´å†…ï¼ˆé˜²æ­¢æº¢å‡ºï¼‰
            x = Math.max(range.minX, Math.min(range.maxX, x));
            
            return 50 + (x - range.minX) / (range.maxX - range.minX) * (width - 100);
        }
        
        function canvasXToPosition(canvasX) {
            const range = getViewRange();
            const width = canvas.width;
            
            // ç¡®ä¿canvasXåœ¨ç”»å¸ƒå†…
            canvasX = Math.max(50, Math.min(width - 50, canvasX));
            
            return range.minX + (canvasX - 50) / (width - 100) * (range.maxX - range.minX);
        }
        
        // ç¼©æ”¾å‡½æ•°
        function zoomIn() {
            zoomLevel *= 1.2;
            zoomLevel = Math.min(zoomLevel, 20); // æœ€å¤§ç¼©æ”¾çº§åˆ«
            drawMotion();
            updateViewInfo();
        }
        
        function zoomOut() {
            zoomLevel *= 0.8;
            zoomLevel = Math.max(zoomLevel, 0.05); // æœ€å°ç¼©æ”¾çº§åˆ«
            drawMotion();
            updateViewInfo();
        }
        
        function zoomToFit() {
            const range = calculateAutoViewRange();
            const rangeWidth = range.maxX - range.minX;
            zoomLevel = 200 / rangeWidth;
            zoomLevel = Math.max(0.05, Math.min(zoomLevel, 20));
            viewCenter = (range.minX + range.maxX) / 2;
            viewMode = 'auto';
            viewRangeSelect.value = 'auto';
            drawMotion();
            updateViewInfo();
        }
        
        function resetView() {
            zoomLevel = 1.0;
            viewCenter = 0;
            viewMode = 'fixed';
            viewRangeSelect.value = 'fixed';
            drawMotion();
            updateViewInfo();
        }
        
        // æ›´æ–°è§†å›¾ä¿¡æ¯æ˜¾ç¤º
        function updateViewInfo() {
            const range = getViewRange();
            const rangeWidth = range.maxX - range.minX;
            const zoomPercent = (200 / rangeWidth * 100).toFixed(0);
            
            let modeText = '';
            switch (viewMode) {
                case 'fixed': modeText = 'å›ºå®šèŒƒå›´'; break;
                case 'followCurrent': modeText = 'è·Ÿéšå½“å‰ä½ç½®'; break;
                case 'showAll': modeText = 'æ˜¾ç¤ºæ‰€æœ‰å†…å®¹'; break;
                case 'largeDisplacement': modeText = 'å¤§ä½ç§»æ¨¡å¼'; break;
                case 'auto': modeText = 'è‡ªåŠ¨è°ƒæ•´'; break;
            }
            
            // æ ¼å¼åŒ–èŒƒå›´æ˜¾ç¤ºï¼ˆå¯¹äºå¤§æ•°å­—ä½¿ç”¨kè¡¨ç¤ºåƒï¼‰
            let minXText = range.minX.toFixed(1);
            let maxXText = range.maxX.toFixed(1);
            let rangeWidthText = rangeWidth.toFixed(1);
            
            if (Math.abs(range.minX) >= 1000) {
                minXText = (range.minX / 1000).toFixed(2) + 'k';
            }
            if (Math.abs(range.maxX) >= 1000) {
                maxXText = (range.maxX / 1000).toFixed(2) + 'k';
            }
            if (rangeWidth >= 1000) {
                rangeWidthText = (rangeWidth / 1000).toFixed(2) + 'k';
            }
            
            document.getElementById('viewInfo').innerHTML = 
                `${modeText} | èŒƒå›´: ${minXText}m ~ ${maxXText}m (${rangeWidthText}m) | ç¼©æ”¾: ${zoomPercent}%`;
            
            // æ›´æ–°æ¯”ä¾‹å°ºä¿¡æ¯
            updateScaleIndicator();
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºå¤§ä½ç§»è­¦å‘Š
            checkLargeDisplacement();
        }
        
        // æ›´æ–°æ¯”ä¾‹å°ºæŒ‡ç¤ºå™¨
        function updateScaleIndicator() {
            if (!document.getElementById('showScaleIndicator').checked) {
                scaleIndicator.style.display = 'none';
                return;
            }
            
            const range = getViewRange();
            const rangeWidth = range.maxX - range.minX;
            
            // è®¡ç®—åˆé€‚çš„æ¯”ä¾‹å°ºé•¿åº¦ï¼ˆåƒç´ ï¼‰
            const canvasWidth = canvas.width - 100; // å‡å»è¾¹è·
            let targetMeters = 100; // é»˜è®¤ç›®æ ‡æ˜¾ç¤º100ç±³
            
            // æ ¹æ®èŒƒå›´è°ƒæ•´æ¯”ä¾‹å°ºé•¿åº¦
            if (rangeWidth > 1000) targetMeters = 500;
            if (rangeWidth > 5000) targetMeters = 1000;
            if (rangeWidth > 10000) targetMeters = 2000;
            if (rangeWidth > 20000) targetMeters = 5000;
            
            // ç¡®ä¿æ¯”ä¾‹å°ºä¸ä¼šå¤ªé•¿
            targetMeters = Math.min(targetMeters, rangeWidth * 0.3);
            
            // è®¡ç®—åƒç´ é•¿åº¦
            const pixelLength = (targetMeters / rangeWidth) * canvasWidth;
            
            // ç¡®ä¿æ¯”ä¾‹å°ºä¸ä¼šå¤ªçŸ­
            if (pixelLength < 50) {
                targetMeters = (50 / canvasWidth) * rangeWidth;
            }
            
            // æ ¼å¼åŒ–æ˜¾ç¤ºæ–‡æœ¬
            let scaleText = `${targetMeters.toFixed(0)} m`;
            if (targetMeters >= 1000) {
                scaleText = `${(targetMeters / 1000).toFixed(1)} km`;
            }
            
            // æ›´æ–°æ¯”ä¾‹å°ºæŒ‡ç¤ºå™¨
            scaleIndicator.innerHTML = `æ¯”ä¾‹å°º: ${scaleText}`;
            scaleIndicator.style.display = 'block';
            
            // æ›´æ–°æ¯”ä¾‹ä¿¡æ¯
            const scaleRatio = Math.round(rangeWidth / 10);
            document.getElementById('scaleInfo').textContent = `æ¯”ä¾‹å°º: 1:${scaleRatio}`;
        }
        
        // æ£€æŸ¥å¤§ä½ç§»å¹¶æ˜¾ç¤ºè­¦å‘Š
        function checkLargeDisplacement() {
            const maxT = getMaxTime();
            const xA_start = calculatePosition('A', 0);
            const xA_end = calculatePosition('A', maxT);
            const xB_start = calculatePosition('B', 0);
            const xB_end = calculatePosition('B', maxT);
            
            const maxDisplacement = Math.max(
                Math.abs(xA_end - xA_start),
                Math.abs(xB_end - xB_start)
            );
            
            if (maxDisplacement > 500) {
                largeDisplacementText.textContent = 
                    `æ£€æµ‹åˆ°å¤§ä½ç§» (${maxDisplacement.toFixed(1)}m)ï¼Œå»ºè®®ä½¿ç”¨"å¤§ä½ç§»æ¨¡å¼"æˆ–æ‰‹åŠ¨è°ƒæ•´è§†å›¾`;
                largeDisplacementWarning.style.display = 'block';
            } else {
                largeDisplacementWarning.style.display = 'none';
            }
        }
        
        // å±…ä¸­æ˜¾ç¤ºç‰¹å®šç‰©ä½“
        function centerOnObject(obj) {
            const t = currentMode === 'single' ? singleParams.t : singleParams.t;
            const x = calculatePosition(obj, t);
            viewCenter = x;
            viewMode = 'followCurrent';
            viewRangeSelect.value = 'followCurrent';
            drawMotion();
            updateViewInfo();
        }
        
        // ==================== æ¨¡å¼åˆ‡æ¢å‡½æ•° ====================
        
        function switchMode(mode) {
            currentMode = mode;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            singleModeBtn.classList.toggle('active', mode === 'single');
            multiModeBtn.classList.toggle('active', mode === 'multi');
            
            // æ›´æ–°é¢æ¿æ˜¾ç¤º
            singleModePanel.style.display = mode === 'single' ? 'block' : 'none';
            multiModePanel.style.display = mode === 'multi' ? 'block' : 'none';
            
            // åœæ­¢åŠ¨ç”»
            stopAnimation();
            
            // é‡ç½®æ—¶é—´
            if (mode === 'single') {
                singleParams.t = 0;
                singleSliders.time.value = 0;
                singleInputs.time.value = '0';
            } else {
                // å¯¹äºå¤šè¿‡ç¨‹æ¨¡å¼ï¼Œé‡æ–°è®¡ç®—è¿‡ç¨‹çŠ¶æ€
                calculateProcessStates();
            }
            
            // é‡æ–°è®¡ç®—å…³é”®æ—¶åˆ»
            calculateSpecialMoments();
            
            // æ›´æ–°æ˜¾ç¤º
            drawMotion();
            updateCharts();
            updateInfoPanel();
            updateMomentsList();
        }
        
        // ==================== å¤šè¿‡ç¨‹ç®¡ç†å‡½æ•° ====================
        
        // åˆ‡æ¢å½“å‰ç¼–è¾‘çš„è¿‡ç¨‹
        function switchProcess(index) {
            currentProcessIndex = index;
            
            // æ›´æ–°æ ‡ç­¾é¡µçŠ¶æ€
            document.querySelectorAll('.process-tab').forEach((tab, i) => {
                tab.classList.toggle('active', i === index);
            });
            
            // æ›´æ–°æ˜¾ç¤º
            currentProcessIndexSpan.textContent = index + 1;
            
            // æ›´æ–°è¾“å…¥æ§ä»¶
            updateMultiProcessControls();
            
            // æ›´æ–°åˆ é™¤æŒ‰é’®çŠ¶æ€
            removeProcessBtn.disabled = multiProcesses.length <= 1;
        }
        
        // æ·»åŠ è¿‡ç¨‹
        function addProcess() {
            if (multiProcesses.length >= 5) {
                alert("æœ€å¤šåªèƒ½æ·»åŠ 5ä¸ªè¿‡ç¨‹");
                return;
            }
            
            // æ·»åŠ æ–°è¿‡ç¨‹ï¼Œå‚æ•°ç»§æ‰¿ä¸Šä¸€ä¸ªè¿‡ç¨‹
            const lastProcess = multiProcesses[multiProcesses.length - 1];
            multiProcesses.push({
                duration: 5, // é»˜è®¤æŒç»­æ—¶é—´
                params: {
                    x0A: null, // åç»­è¿‡ç¨‹ä¸éœ€è¦åˆå§‹ä½ç½®
                    x0B: null, // åç»­è¿‡ç¨‹ä¸éœ€è¦åˆå§‹ä½ç½®
                    v0A: lastProcess.params.v0A,
                    aA: lastProcess.params.aA,
                    v0B: lastProcess.params.v0B,
                    aB: lastProcess.params.aB,
                    brakeA: lastProcess.params.brakeA,
                    brakeB: lastProcess.params.brakeB
                }
            });
            
            // æ›´æ–°ç•Œé¢
            updateProcessTabs();
            switchProcess(multiProcesses.length - 1);
            
            // é‡æ–°è®¡ç®—
            calculateProcessStates();
            calculateSpecialMoments();
            drawMotion();
            updateCharts();
        }
        
        // åˆ é™¤å½“å‰è¿‡ç¨‹
        function removeProcess() {
            if (multiProcesses.length <= 1) return;
            
            multiProcesses.splice(currentProcessIndex, 1);
            
            // è°ƒæ•´å½“å‰ç´¢å¼•
            if (currentProcessIndex >= multiProcesses.length) {
                currentProcessIndex = multiProcesses.length - 1;
            }
            
            // æ›´æ–°ç•Œé¢
            updateProcessTabs();
            switchProcess(currentProcessIndex);
            
            // é‡æ–°è®¡ç®—
            calculateProcessStates();
            calculateSpecialMoments();
            drawMotion();
            updateCharts();
        }
        
        // é‡ç½®å¤šè¿‡ç¨‹
        function resetMultiProcess() {
            multiProcesses = [
                {
                    duration: 10,
                    params: {
                        x0A: 0,
                        x0B: 30,
                        v0A: 10,
                        aA: 0,
                        v0B: 5,
                        aB: 0,
                        brakeA: false,
                        brakeB: false
                    }
                }
            ];
            
            // é‡ç½®å¤šè¿‡ç¨‹è¾“å…¥æ§ä»¶
            multiInputs.x0A.value = '0';
            multiInputs.v0A.value = '10';
            multiInputs.aA.value = '0';
            multiInputs.x0B.value = '30';
            multiInputs.v0B.value = '5';
            multiInputs.aB.value = '0';
            multiInputs.duration.value = '10';
            
            multiSliders.x0A.value = '0';
            multiSliders.v0A.value = '10';
            multiSliders.aA.value = '0';
            multiSliders.x0B.value = '30';
            multiSliders.v0B.value = '5';
            multiSliders.aB.value = '0';
            multiSliders.duration.value = '10';
            
            multiBrakeA.checked = false;
            multiBrakeB.checked = false;
            
            // æ›´æ–°ç•Œé¢
            updateProcessTabs();
            switchProcess(0);
            
            // é‡æ–°è®¡ç®—
            calculateProcessStates();
            calculateSpecialMoments();
            drawMotion();
            updateCharts();
        }
        
        // æ›´æ–°è¿‡ç¨‹æ ‡ç­¾é¡µ
        function updateProcessTabs() {
            processTabs.innerHTML = '';
            multiProcesses.forEach((process, index) => {
                const tab = document.createElement('div');
                tab.className = `process-tab ${index === currentProcessIndex ? 'active' : ''}`;
                tab.textContent = `è¿‡ç¨‹ ${index + 1}`;
                tab.onclick = () => switchProcess(index);
                processTabs.appendChild(tab);
            });
            
            totalProcessesSpan.textContent = multiProcesses.length;
        }
        
        // æ›´æ–°å¤šè¿‡ç¨‹æ§åˆ¶é¢æ¿
        function updateMultiProcessControls() {
            const process = multiProcesses[currentProcessIndex];
            
            // æ›´æ–°è¾“å…¥æ§ä»¶
            if (currentProcessIndex === 0) {
                // è¿‡ç¨‹1ï¼šæ˜¾ç¤ºåˆå§‹ä½ç½®
                document.getElementById('multiX0AGroup').style.display = 'block';
                document.getElementById('multiX0BGroup').style.display = 'block';
                document.getElementById('multiX0ANote').textContent = 'è¿‡ç¨‹1çš„åˆå§‹ä½ç½®';
                document.getElementById('multiX0BNote').textContent = 'è¿‡ç¨‹1çš„åˆå§‹ä½ç½®';
                document.getElementById('multiV0ANote').textContent = 'è¿‡ç¨‹1çš„åˆé€Ÿåº¦';
                document.getElementById('multiV0BNote').textContent = 'è¿‡ç¨‹1çš„åˆé€Ÿåº¦';
                
                multiInputs.x0A.value = process.params.x0A !== null ? process.params.x0A.toFixed(1) : '0';
                multiInputs.x0B.value = process.params.x0B !== null ? process.params.x0B.toFixed(1) : '30';
                multiSliders.x0A.value = process.params.x0A !== null ? process.params.x0A : 0;
                multiSliders.x0B.value = process.params.x0B !== null ? process.params.x0B : 30;
            } else {
                // åç»­è¿‡ç¨‹ï¼šéšè—åˆå§‹ä½ç½®
                document.getElementById('multiX0AGroup').style.display = 'none';
                document.getElementById('multiX0BGroup').style.display = 'none';
                document.getElementById('multiV0ANote').textContent = 'ç»§æ‰¿ä¸Šä¸€è¿‡ç¨‹æœ«é€Ÿåº¦';
                document.getElementById('multiV0BNote').textContent = 'ç»§æ‰¿ä¸Šä¸€è¿‡ç¨‹æœ«é€Ÿåº¦';
            }
            
            multiInputs.v0A.value = process.params.v0A.toFixed(1);
            multiInputs.aA.value = process.params.aA.toFixed(1);
            multiInputs.v0B.value = process.params.v0B.toFixed(1);
            multiInputs.aB.value = process.params.aB.toFixed(1);
            multiInputs.duration.value = process.duration.toFixed(1);
            
            multiSliders.v0A.value = process.params.v0A;
            multiSliders.aA.value = process.params.aA;
            multiSliders.v0B.value = process.params.v0B;
            multiSliders.aB.value = process.params.aB;
            multiSliders.duration.value = process.duration;
            
            multiBrakeA.checked = process.params.brakeA;
            multiBrakeB.checked = process.params.brakeB;
        }
        
        // è®¡ç®—è¿‡ç¨‹çŠ¶æ€ï¼ˆå¼€å§‹æ—¶é—´ã€ç»“æŸæ—¶é—´ï¼‰
        function calculateProcessStates() {
            processStates = [];
            let startTime = 0;
            
            multiProcesses.forEach((process, index) => {
                const endTime = startTime + process.duration;
                processStates.push({
                    index: index,
                    startTime: startTime,
                    endTime: endTime,
                    duration: process.duration
                });
                startTime = endTime;
            });
        }
        
        // è·å–å½“å‰è¿‡ç¨‹å’Œæ—¶é—´åç§»
        function getCurrentProcessAndOffset(t) {
            if (currentMode === 'single') {
                return { processIndex: 0, processOffset: t, inProcess: true };
            }
            
            let accumulatedTime = 0;
            for (let i = 0; i < multiProcesses.length; i++) {
                if (t >= accumulatedTime && t <= accumulatedTime + multiProcesses[i].duration) {
                    return {
                        processIndex: i,
                        processOffset: t - accumulatedTime,
                        inProcess: true
                    };
                }
                accumulatedTime += multiProcesses[i].duration;
            }
            
            // å¦‚æœæ—¶é—´è¶…è¿‡æ€»æ—¶é—´ï¼Œè¿”å›æœ€åä¸€ä¸ªè¿‡ç¨‹
            const lastIndex = multiProcesses.length - 1;
            return {
                processIndex: lastIndex,
                processOffset: multiProcesses[lastIndex].duration,
                inProcess: false
            };
        }
        
        // ==================== æ ¸å¿ƒç‰©ç†è®¡ç®—å‡½æ•° ====================
        
        // è®¡ç®—åœè½¦æ—¶é—´ï¼ˆåˆ¹è½¦æ¨¡å¼ï¼‰
        function calculateStopTime(v0, a) {
            if (a >= 0) return null; // åŠ é€Ÿæˆ–åŒ€é€Ÿï¼Œä¸ä¼šåœæ­¢
            return -v0 / a; // t = -vâ‚€/a
        }
        
        // è®¡ç®—ç‰©ä½“ä½ç½®ï¼ˆè€ƒè™‘åˆ¹è½¦å’Œå¤šè¿‡ç¨‹ï¼‰
        function calculatePosition(obj, t) {
            const state = objectStates[obj];
            
            if (currentMode === 'single') {
                // å•è¿‡ç¨‹æ¨¡å¼
                const isBrake = obj === 'A' ? brakeA.checked : brakeB.checked;
                
                // å¦‚æœä¸å¯ç”¨åˆ¹è½¦æˆ–ä¸ä¼šåœæ­¢ï¼Œä½¿ç”¨æ ‡å‡†å…¬å¼
                if (!isBrake || state.stopTime === null || t < state.stopTime) {
                    const x0 = singleParams[`x0${obj}`];
                    const v0 = singleParams[`v0${obj}`];
                    const a = singleParams[`a${obj}`];
                    return x0 + v0 * t + 0.5 * a * t * t;
                }
                
                // å·²ç»åœæ­¢ï¼Œè¿”å›åœæ­¢ä½ç½®
                return state.stopPosition;
            } else {
                // å¤šè¿‡ç¨‹æ¨¡å¼
                const { processIndex, processOffset, inProcess } = getCurrentProcessAndOffset(t);
                
                if (!inProcess) {
                    // è¶…è¿‡æ€»æ—¶é—´ï¼Œè¿”å›æœ€åä¸€ä¸ªä½ç½®
                    const lastProcess = processStates[processStates.length - 1];
                    return calculatePosition(obj, lastProcess.endTime);
                }
                
                // è®¡ç®—åˆå§‹ä½ç½®å’Œé€Ÿåº¦ï¼ˆè¿‡ç¨‹1ä½¿ç”¨è®¾å®šçš„åˆå§‹å€¼ï¼Œåç»­è¿‡ç¨‹ç»§æ‰¿ï¼‰
                let currentX = 0;
                let currentV = 0;
                
                // è¿‡ç¨‹1ï¼šä½¿ç”¨è®¾å®šçš„åˆå§‹ä½ç½®å’Œåˆé€Ÿåº¦
                if (processIndex === 0) {
                    const process = multiProcesses[0];
                    currentX = obj === 'A' ? process.params.x0A : process.params.x0B;
                    currentV = obj === 'A' ? process.params.v0A : process.params.v0B;
                    
                    // å¦‚æœä¸å¯ç”¨åˆ¹è½¦æˆ–ä¸ä¼šåœæ­¢ï¼Œä½¿ç”¨æ ‡å‡†å…¬å¼
                    const isBrake = obj === 'A' ? process.params.brakeA : process.params.brakeB;
                    const a = obj === 'A' ? process.params.aA : process.params.aB;
                    
                    if (!isBrake || state.stopTime === null || t < state.stopTime) {
                        return currentX + currentV * processOffset + 0.5 * a * processOffset * processOffset;
                    } else {
                        // å·²ç»åœæ­¢ï¼Œè¿”å›åœæ­¢ä½ç½®
                        return state.stopPosition;
                    }
                } else {
                    // åç»­è¿‡ç¨‹ï¼šéœ€è¦è®¡ç®—ä¸Šä¸€è¿‡ç¨‹ç»“æŸæ—¶çš„ä½ç½®å’Œé€Ÿåº¦
                    // å…ˆè®¡ç®—ä¸Šä¸€è¿‡ç¨‹ç»“æŸæ—¶çš„çŠ¶æ€
                    let accumulatedTime = 0;
                    for (let i = 0; i < processIndex; i++) {
                        const process = multiProcesses[i];
                        const duration = process.duration;
                        const params = process.params;
                        
                        // è®¡ç®—è¿™ä¸ªè¿‡ç¨‹çš„åˆå§‹é€Ÿåº¦ï¼ˆç¬¬ä¸€æ¬¡å¾ªç¯ä½¿ç”¨è¿‡ç¨‹1çš„åˆå§‹é€Ÿåº¦ï¼‰
                        if (i === 0) {
                            currentX = obj === 'A' ? params.x0A : params.x0B;
                            currentV = obj === 'A' ? params.v0A : params.v0B;
                        }
                        
                        const a = params[`a${obj}`];
                        const isBrake = obj === 'A' ? params.brakeA : params.brakeB;
                        const stopTime = state.stopTime;
                        
                        // å¦‚æœåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­åœæ­¢
                        if (isBrake && stopTime !== null && stopTime >= accumulatedTime && stopTime <= accumulatedTime + duration) {
                            const stopOffset = stopTime - accumulatedTime;
                            currentX = currentX + currentV * stopOffset + 0.5 * a * stopOffset * stopOffset;
                            currentV = 0;
                            // å·²ç»åœæ­¢ï¼Œç›´æ¥è¿”å›åœæ­¢ä½ç½®
                            return currentX;
                        } else {
                            // æ•´ä¸ªè¿‡ç¨‹éƒ½åœ¨è¿åŠ¨
                            currentX = currentX + currentV * duration + 0.5 * a * duration * duration;
                            currentV = currentV + a * duration;
                        }
                        
                        accumulatedTime += duration;
                    }
                    
                    // å½“å‰è¿‡ç¨‹
                    const currentProcess = multiProcesses[processIndex];
                    const params = currentProcess.params;
                    const isBrake = obj === 'A' ? params.brakeA : params.brakeB;
                    const a = params[`a${obj}`];
                    
                    // å¦‚æœä¸å¯ç”¨åˆ¹è½¦æˆ–ä¸ä¼šåœæ­¢ï¼Œä½¿ç”¨æ ‡å‡†å…¬å¼
                    if (!isBrake || state.stopTime === null || t < state.stopTime) {
                        return currentX + currentV * processOffset + 0.5 * a * processOffset * processOffset;
                    }
                    
                    // å·²ç»åœæ­¢ï¼Œè¿”å›åœæ­¢ä½ç½®
                    return state.stopPosition;
                }
            }
        }
        
        // è®¡ç®—ç‰©ä½“é€Ÿåº¦ï¼ˆè€ƒè™‘åˆ¹è½¦å’Œå¤šè¿‡ç¨‹ï¼‰
        function calculateVelocity(obj, t) {
            const state = objectStates[obj];
            
            if (currentMode === 'single') {
                // å•è¿‡ç¨‹æ¨¡å¼
                const isBrake = obj === 'A' ? brakeA.checked : brakeB.checked;
                
                // å¦‚æœä¸å¯ç”¨åˆ¹è½¦æˆ–ä¸ä¼šåœæ­¢ï¼Œä½¿ç”¨æ ‡å‡†å…¬å¼
                if (!isBrake || state.stopTime === null || t < state.stopTime) {
                    const v0 = singleParams[`v0${obj}`];
                    const a = singleParams[`a${obj}`];
                    return v0 + a * t;
                }
                
                // å·²ç»åœæ­¢ï¼Œé€Ÿåº¦ä¸º0
                return 0;
            } else {
                // å¤šè¿‡ç¨‹æ¨¡å¼
                const { processIndex, processOffset, inProcess } = getCurrentProcessAndOffset(t);
                
                if (!inProcess) {
                    // è¶…è¿‡æ€»æ—¶é—´ï¼Œé€Ÿåº¦ä¸ºæœ€åä¸€ä¸ªè¿‡ç¨‹ç»“æŸæ—¶çš„é€Ÿåº¦
                    const lastProcess = processStates[processStates.length - 1];
                    return calculateVelocity(obj, lastProcess.endTime);
                }
                
                // è¿‡ç¨‹1ï¼šä½¿ç”¨è®¾å®šçš„åˆé€Ÿåº¦
                if (processIndex === 0) {
                    const process = multiProcesses[0];
                    const isBrake = obj === 'A' ? process.params.brakeA : process.params.brakeB;
                    const a = obj === 'A' ? process.params.aA : process.params.aB;
                    const v0 = obj === 'A' ? process.params.v0A : process.params.v0B;
                    
                    // å¦‚æœä¸å¯ç”¨åˆ¹è½¦æˆ–ä¸ä¼šåœæ­¢ï¼Œä½¿ç”¨æ ‡å‡†å…¬å¼
                    if (!isBrake || state.stopTime === null || t < state.stopTime) {
                        return v0 + a * processOffset;
                    }
                    
                    // å·²ç»åœæ­¢ï¼Œé€Ÿåº¦ä¸º0
                    return 0;
                } else {
                    // åç»­è¿‡ç¨‹ï¼šéœ€è¦è®¡ç®—ä¸Šä¸€è¿‡ç¨‹ç»“æŸæ—¶çš„é€Ÿåº¦
                    // å…ˆè®¡ç®—ä¸Šä¸€è¿‡ç¨‹ç»“æŸæ—¶çš„é€Ÿåº¦
                    let currentV = 0;
                    let accumulatedTime = 0;
                    
                    for (let i = 0; i < processIndex; i++) {
                        const process = multiProcesses[i];
                        const duration = process.duration;
                        const params = process.params;
                        
                        // è®¡ç®—è¿™ä¸ªè¿‡ç¨‹çš„åˆå§‹é€Ÿåº¦ï¼ˆç¬¬ä¸€æ¬¡å¾ªç¯ä½¿ç”¨è¿‡ç¨‹1çš„åˆå§‹é€Ÿåº¦ï¼‰
                        if (i === 0) {
                            currentV = obj === 'A' ? params.v0A : params.v0B;
                        }
                        
                        const a = params[`a${obj}`];
                        const isBrake = obj === 'A' ? params.brakeA : params.brakeB;
                        const stopTime = state.stopTime;
                        
                        // å¦‚æœåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­åœæ­¢
                        if (isBrake && stopTime !== null && stopTime >= accumulatedTime && stopTime <= accumulatedTime + duration) {
                            return 0; // å·²ç»åœæ­¢
                        } else {
                            // æ•´ä¸ªè¿‡ç¨‹éƒ½åœ¨è¿åŠ¨
                            currentV = currentV + a * duration;
                        }
                        
                        accumulatedTime += duration;
                    }
                    
                    // å½“å‰è¿‡ç¨‹
                    const currentProcess = multiProcesses[processIndex];
                    const params = currentProcess.params;
                    const isBrake = obj === 'A' ? params.brakeA : params.brakeB;
                    const a = params[`a${obj}`];
                    
                    // å¦‚æœä¸å¯ç”¨åˆ¹è½¦æˆ–ä¸ä¼šåœæ­¢ï¼Œä½¿ç”¨æ ‡å‡†å…¬å¼
                    if (!isBrake || state.stopTime === null || t < state.stopTime) {
                        return currentV + a * processOffset;
                    }
                    
                    // å·²ç»åœæ­¢ï¼Œé€Ÿåº¦ä¸º0
                    return 0;
                }
            }
        }
        
        // è®¡ç®—ç‰©ä½“æ˜¯å¦åœ¨è¿åŠ¨
        function calculateIsMoving(obj, t) {
            const state = objectStates[obj];
            
            if (currentMode === 'single') {
                const isBrake = obj === 'A' ? brakeA.checked : brakeB.checked;
                if (!isBrake || state.stopTime === null) return true;
                return t < state.stopTime;
            } else {
                const { processIndex, processOffset, inProcess } = getCurrentProcessAndOffset(t);
                if (!inProcess) return false;
                
                const currentProcess = multiProcesses[processIndex];
                const isBrake = obj === 'A' ? currentProcess.params.brakeA : currentProcess.params.brakeB;
                if (!isBrake || state.stopTime === null) return true;
                return t < state.stopTime;
            }
        }
        
        // è®¡ç®—ç‰©ä½“è¿åŠ¨æ—¶é—´ï¼ˆè€ƒè™‘åˆ¹è½¦åœæ­¢ï¼‰
        function calculateMovementTime(obj, t) {
            const state = objectStates[obj];
            
            if (currentMode === 'single') {
                const isBrake = obj === 'A' ? brakeA.checked : brakeB.checked;
                if (!isBrake || state.stopTime === null) {
                    return t; // ä¸€ç›´è¿åŠ¨
                } else {
                    return Math.min(t, state.stopTime); // å¦‚æœå·²åœæ­¢ï¼Œè¿”å›åœæ­¢æ—¶é—´
                }
            } else {
                // å¤šè¿‡ç¨‹æ¨¡å¼
                const { processIndex, processOffset, inProcess } = getCurrentProcessAndOffset(t);
                
                if (!inProcess) {
                    // è¶…è¿‡æ€»æ—¶é—´ï¼Œè¿”å›æ€»è¿åŠ¨æ—¶é—´
                    const lastProcess = processStates[processStates.length - 1];
                    return calculateMovementTime(obj, lastProcess.endTime);
                }
                
                // è®¡ç®—å½“å‰è¿‡ç¨‹å¼€å§‹æ—¶çš„ç´¯è®¡è¿åŠ¨æ—¶é—´
                let accumulatedMovementTime = 0;
                let accumulatedTime = 0;
                
                for (let i = 0; i < processIndex; i++) {
                    const process = multiProcesses[i];
                    const params = process.params;
                    const isBrake = obj === 'A' ? params.brakeA : params.brakeB;
                    
                    if (isBrake && objectStates[obj].stopTime !== null && 
                        objectStates[obj].stopTime <= accumulatedTime + process.duration) {
                        // åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­å·²ç»åœæ­¢
                        accumulatedMovementTime += Math.max(0, objectStates[obj].stopTime - accumulatedTime);
                        return accumulatedMovementTime;
                    } else {
                        // æ•´ä¸ªè¿‡ç¨‹éƒ½åœ¨è¿åŠ¨
                        accumulatedMovementTime += process.duration;
                    }
                    
                    accumulatedTime += process.duration;
                }
                
                // å½“å‰è¿‡ç¨‹
                const currentProcess = multiProcesses[processIndex];
                const isBrake = obj === 'A' ? currentProcess.params.brakeA : currentProcess.params.brakeB;
                
                if (isBrake && objectStates[obj].stopTime !== null && 
                    objectStates[obj].stopTime <= accumulatedTime + processOffset) {
                    // åœ¨å½“å‰è¿‡ç¨‹ä¸­å·²åœæ­¢
                    return accumulatedMovementTime + Math.max(0, objectStates[obj].stopTime - accumulatedTime);
                } else {
                    // è¿˜åœ¨è¿åŠ¨
                    return accumulatedMovementTime + processOffset;
                }
            }
        }
        
        // è®¡ç®—ç‰©ä½“åŠ é€Ÿåº¦
        function calculateAcceleration(obj, t) {
            if (currentMode === 'single') {
                // å•è¿‡ç¨‹æ¨¡å¼
                const isBrake = obj === 'A' ? brakeA.checked : brakeB.checked;
                const a = singleParams[`a${obj}`];
                
                // å¦‚æœå¯ç”¨äº†åˆ¹è½¦ä¸”å·²ç»åœæ­¢ï¼ŒåŠ é€Ÿåº¦ä¸º0
                if (isBrake && objectStates[obj].stopTime !== null && t >= objectStates[obj].stopTime) {
                    return 0;
                }
                return a;
            } else {
                // å¤šè¿‡ç¨‹æ¨¡å¼
                const { processIndex, inProcess } = getCurrentProcessAndOffset(t);
                
                if (!inProcess) {
                    // è¶…è¿‡æ€»æ—¶é—´ï¼Œè¿”å›æœ€åä¸€ä¸ªè¿‡ç¨‹çš„åŠ é€Ÿåº¦ï¼ˆå¦‚æœåœæ­¢åˆ™ä¸º0ï¼‰
                    const lastProcess = multiProcesses[multiProcesses.length - 1];
                    const isBrake = obj === 'A' ? lastProcess.params.brakeA : lastProcess.params.brakeB;
                    
                    if (isBrake && objectStates[obj].stopTime !== null && t >= objectStates[obj].stopTime) {
                        return 0;
                    }
                    return obj === 'A' ? lastProcess.params.aA : lastProcess.params.aB;
                }
                
                // å½“å‰è¿‡ç¨‹
                const currentProcess = multiProcesses[processIndex];
                const isBrake = obj === 'A' ? currentProcess.params.brakeA : currentProcess.params.brakeB;
                const a = obj === 'A' ? currentProcess.params.aA : currentProcess.params.aB;
                
                // å¦‚æœå¯ç”¨äº†åˆ¹è½¦ä¸”å·²ç»åœæ­¢ï¼ŒåŠ é€Ÿåº¦ä¸º0
                if (isBrake && objectStates[obj].stopTime !== null && t >= objectStates[obj].stopTime) {
                    return 0;
                }
                return a;
            }
        }
        
        // è®¡ç®—ä¸¤è½¦è·ç¦»
        function calculateDistance(t) {
            const xA = calculatePosition('A', t);
            const xB = calculatePosition('B', t);
            return Math.abs(xA - xB);
        }
        
        // è·å–æœ€å¤§æ—¶é—´ï¼ˆå•è¿‡ç¨‹æˆ–å¤šè¿‡ç¨‹æ€»æ—¶é—´ï¼‰
        function getMaxTime() {
            if (currentMode === 'single') {
                return singleParams.maxT;
            } else {
                // è®¡ç®—å¤šè¿‡ç¨‹æ€»æ—¶é—´
                return multiProcesses.reduce((total, process) => total + process.duration, 0);
            }
        }
        
        // è·å–å½“å‰æ—¶é—´åœ¨å“ªä¸ªè¿‡ç¨‹
        function getCurrentProcessInfo(t) {
            if (currentMode === 'single') {
                return { processIndex: 0, processOffset: t, processStart: 0, processEnd: singleParams.maxT };
            }
            
            let accumulatedTime = 0;
            for (let i = 0; i < multiProcesses.length; i++) {
                const processDuration = multiProcesses[i].duration;
                if (t >= accumulatedTime && t <= accumulatedTime + processDuration) {
                    return {
                        processIndex: i,
                        processOffset: t - accumulatedTime,
                        processStart: accumulatedTime,
                        processEnd: accumulatedTime + processDuration
                    };
                }
                accumulatedTime += processDuration;
            }
            
            // å¦‚æœè¶…è¿‡æ€»æ—¶é—´ï¼Œè¿”å›æœ€åä¸€ä¸ªè¿‡ç¨‹
            const lastIndex = multiProcesses.length - 1;
            const lastStart = accumulatedTime - multiProcesses[lastIndex].duration;
            return {
                processIndex: lastIndex,
                processOffset: multiProcesses[lastIndex].duration,
                processStart: lastStart,
                processEnd: accumulatedTime
            };
        }
        
        // ==================== å…³é”®æ—¶åˆ»è®¡ç®— ====================
        
        // é‡æ–°è®¡ç®—æ‰€æœ‰å…³é”®æ—¶åˆ»
        function calculateSpecialMoments() {
            console.log("è®¡ç®—å…³é”®æ—¶åˆ»...");
            specialMoments = [];
            
            // é‡ç½®ç‰©ä½“çŠ¶æ€
            objectStates.A = { isMoving: true, stopTime: null, stopPosition: null, movementTime: 0 };
            objectStates.B = { isMoving: true, stopTime: null, stopPosition: null, movementTime: 0 };
            
            // åˆå§‹æ—¶åˆ»
            specialMoments.push({
                time: 0,
                type: 'initial',
                description: 'åˆå§‹æ—¶åˆ»',
                color: '#2ecc71'
            });
            
            console.log("æ·»åŠ åˆå§‹æ—¶åˆ»");
            
            // è®¡ç®—æœ€å¤§æ—¶é—´
            const maxT = getMaxTime();
            
            // è®¡ç®—åœè½¦æ—¶åˆ»
            if (currentMode === 'single') {
                // å•è¿‡ç¨‹æ¨¡å¼
                if (brakeA.checked && singleParams.aA < 0) {
                    const stopTimeA = calculateStopTime(singleParams.v0A, singleParams.aA);
                    if (stopTimeA !== null && stopTimeA > 0 && stopTimeA <= maxT) {
                        objectStates.A.stopTime = stopTimeA;
                        objectStates.A.stopPosition = singleParams.x0A + singleParams.v0A * stopTimeA + 0.5 * singleParams.aA * stopTimeA * stopTimeA;
                        specialMoments.push({
                            time: stopTimeA,
                            type: 'stop',
                            description: 'Aè½¦åœè½¦',
                            color: '#e74c3c'
                        });
                        console.log("æ·»åŠ Aè½¦åœè½¦æ—¶åˆ»:", stopTimeA);
                    }
                }
                
                if (brakeB.checked && singleParams.aB < 0) {
                    const stopTimeB = calculateStopTime(singleParams.v0B, singleParams.aB);
                    if (stopTimeB !== null && stopTimeB > 0 && stopTimeB <= maxT) {
                        objectStates.B.stopTime = stopTimeB;
                        objectStates.B.stopPosition = singleParams.x0B + singleParams.v0B * stopTimeB + 0.5 * singleParams.aB * stopTimeB * stopTimeB;
                        specialMoments.push({
                            time: stopTimeB,
                            type: 'stop',
                            description: 'Bè½¦åœè½¦',
                            color: '#e74c3c'
                        });
                        console.log("æ·»åŠ Bè½¦åœè½¦æ—¶åˆ»:", stopTimeB);
                    }
                }
            } else {
                // å¤šè¿‡ç¨‹æ¨¡å¼ - éœ€è¦éå†æ¯ä¸ªè¿‡ç¨‹è®¡ç®—åœè½¦æ—¶åˆ»
                let accumulatedTime = 0;
                for (let i = 0; i < multiProcesses.length; i++) {
                    const process = multiProcesses[i];
                    const params = process.params;
                    
                    // è®¡ç®—è¿™ä¸ªè¿‡ç¨‹çš„åˆå§‹é€Ÿåº¦
                    let v0A = 0;
                    let v0B = 0;
                    
                    if (i === 0) {
                        // è¿‡ç¨‹1ï¼šä½¿ç”¨è®¾å®šçš„åˆé€Ÿåº¦
                        v0A = params.v0A;
                        v0B = params.v0B;
                    } else {
                        // åç»­è¿‡ç¨‹ï¼šéœ€è¦è®¡ç®—ä¸Šä¸€è¿‡ç¨‹ç»“æŸæ—¶çš„é€Ÿåº¦
                        // è¿™é‡Œç®€åŒ–è®¡ç®—ï¼Œå®é™…åº”è¯¥ç”¨å¾ªç¯è®¡ç®—
                        for (let j = 0; j < i; j++) {
                            const prevProcess = multiProcesses[j];
                            const prevParams = prevProcess.params;
                            const prevDuration = prevProcess.duration;
                            
                            // è®¡ç®—ä¸Šä¸€è¿‡ç¨‹çš„æœ«é€Ÿåº¦
                            if (j === 0) {
                                v0A = prevParams.v0A;
                                v0B = prevParams.v0B;
                            }
                            
                            v0A += prevParams.aA * prevDuration;
                            v0B += prevParams.aB * prevDuration;
                        }
                    }
                    
                    // è®¡ç®—Aè½¦åœè½¦æ—¶åˆ»
                    if (params.brakeA && params.aA < 0) {
                        const stopTimeInProcess = calculateStopTime(v0A, params.aA);
                        if (stopTimeInProcess !== null && stopTimeInProcess > 0 && stopTimeInProcess <= process.duration) {
                            const stopTime = accumulatedTime + stopTimeInProcess;
                            if (stopTime <= maxT) {
                                objectStates.A.stopTime = stopTime;
                                // è®¡ç®—åœè½¦ä½ç½®
                                let xA = params.x0A !== null ? params.x0A : 0;
                                
                                // è®¡ç®—åœè½¦ä½ç½®ï¼ˆéœ€è¦ç´¯åŠ å‰é¢è¿‡ç¨‹çš„å½±å“ï¼‰
                                let currentVA = params.v0A;
                                for (let j = 0; j < i; j++) {
                                    const p = multiProcesses[j];
                                    const pParams = p.params;
                                    const pDuration = p.duration;
                                    
                                    // åˆå§‹ä½ç½®åªå¯¹è¿‡ç¨‹1æœ‰æ•ˆ
                                    if (j === 0) {
                                        xA = pParams.x0A !== null ? pParams.x0A : 0;
                                        currentVA = pParams.v0A;
                                    }
                                    
                                    xA += currentVA * pDuration + 0.5 * pParams.aA * pDuration * pDuration;
                                    currentVA += pParams.aA * pDuration;
                                }
                                
                                // å½“å‰è¿‡ç¨‹çš„åœè½¦ä½ç½®
                                objectStates.A.stopPosition = xA + currentVA * stopTimeInProcess + 0.5 * params.aA * stopTimeInProcess * stopTimeInProcess;
                                
                                specialMoments.push({
                                    time: stopTime,
                                    type: 'stop',
                                    description: `Aè½¦åœè½¦ (è¿‡ç¨‹${i+1})`,
                                    color: '#e74c3c'
                                });
                            }
                        }
                    }
                    
                    // è®¡ç®—Bè½¦åœè½¦æ—¶åˆ»
                    if (params.brakeB && params.aB < 0) {
                        const stopTimeInProcess = calculateStopTime(v0B, params.aB);
                        if (stopTimeInProcess !== null && stopTimeInProcess > 0 && stopTimeInProcess <= process.duration) {
                            const stopTime = accumulatedTime + stopTimeInProcess;
                            if (stopTime <= maxT) {
                                objectStates.B.stopTime = stopTime;
                                // è®¡ç®—åœè½¦ä½ç½®
                                let xB = params.x0B !== null ? params.x0B : 30;
                                
                                // è®¡ç®—åœè½¦ä½ç½®ï¼ˆéœ€è¦ç´¯åŠ å‰é¢è¿‡ç¨‹çš„å½±å“ï¼‰
                                let currentVB = params.v0B;
                                for (let j = 0; j < i; j++) {
                                    const p = multiProcesses[j];
                                    const pParams = p.params;
                                    const pDuration = p.duration;
                                    
                                    // åˆå§‹ä½ç½®åªå¯¹è¿‡ç¨‹1æœ‰æ•ˆ
                                    if (j === 0) {
                                        xB = pParams.x0B !== null ? pParams.x0B : 30;
                                        currentVB = pParams.v0B;
                                    }
                                    
                                    xB += currentVB * pDuration + 0.5 * pParams.aB * pDuration * pDuration;
                                    currentVB += pParams.aB * pDuration;
                                }
                                
                                // å½“å‰è¿‡ç¨‹çš„åœè½¦ä½ç½®
                                objectStates.B.stopPosition = xB + currentVB * stopTimeInProcess + 0.5 * params.aB * stopTimeInProcess * stopTimeInProcess;
                                
                                specialMoments.push({
                                    time: stopTime,
                                    type: 'stop',
                                    description: `Bè½¦åœè½¦ (è¿‡ç¨‹${i+1})`,
                                    color: '#e74c3c'
                                });
                            }
                        }
                    }
                    
                    accumulatedTime += process.duration;
                }
            }
            
            // è®¡ç®—ç›¸é‡æ—¶åˆ»
            calculateMeetingMoments();
            
            // è®¡ç®—è·ç¦»æå€¼æ—¶åˆ»
            calculateExtremeMoments();
            
            // æ·»åŠ è¿‡ç¨‹åˆ‡æ¢æ—¶åˆ»
            if (currentMode === 'multi') {
                let accumulatedTime = 0;
                for (let i = 1; i < multiProcesses.length; i++) {
                    accumulatedTime += multiProcesses[i-1].duration;
                    specialMoments.push({
                        time: accumulatedTime,
                        type: 'process',
                        description: `åˆ‡æ¢åˆ°è¿‡ç¨‹${i+1}`,
                        color: '#95a5a6'
                    });
                }
            }
            
            // æŒ‰æ—¶é—´æ’åº
            specialMoments.sort((a, b) => a.time - b.time);
            
            console.log("å…³é”®æ—¶åˆ»è®¡ç®—å®Œæˆï¼Œå…±", specialMoments.length, "ä¸ªæ—¶åˆ»");
            
            // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
            updateStatusDisplay();
            
            // ç«‹å³æ›´æ–°å…³é”®æ—¶åˆ»åˆ—è¡¨
            updateMomentsList();
        }
        
        // è®¡ç®—ç›¸é‡æ—¶åˆ»
        function calculateMeetingMoments() {
            console.log("è®¡ç®—ç›¸é‡æ—¶åˆ»...");
            // ä½¿ç”¨æ•°å€¼æ–¹æ³•æŸ¥æ‰¾ç›¸é‡ç‚¹
            const timeStep = 0.05;
            const maxT = getMaxTime();
            let lastXDiff = calculatePosition('A', 0) - calculatePosition('B', 0);
            
            for (let t = timeStep; t <= maxT; t += timeStep) {
                const xA = calculatePosition('A', t);
                const xB = calculatePosition('B', t);
                const xDiff = xA - xB;
                
                // æ£€æµ‹ç¬¦å·å˜åŒ–ï¼Œè¡¨ç¤ºç›¸é‡
                if (lastXDiff * xDiff <= 0 && Math.abs(xDiff) < 5) {
                    // äºŒåˆ†æ³•ç²¾ç¡®æŸ¥æ‰¾
                    let left = t - timeStep;
                    let right = t;
                    let meetingTime = t;
                    
                    for (let i = 0; i < 10; i++) {
                        meetingTime = (left + right) / 2;
                        const xA_mid = calculatePosition('A', meetingTime);
                        const xB_mid = calculatePosition('B', meetingTime);
                        const diff = xA_mid - xB_mid;
                        
                        if (Math.abs(diff) < 0.01) {
                            break;
                        } else if (diff * (xA - xB) > 0) {
                            right = meetingTime;
                        } else {
                            left = meetingTime;
                        }
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨ç›¸è¿‘çš„ç›¸é‡æ—¶åˆ»
                    const existing = specialMoments.find(
                        m => m.type === 'meeting' && Math.abs(m.time - meetingTime) < 0.1
                    );
                    
                    if (!existing) {
                        const meetingCount = specialMoments.filter(m => m.type === 'meeting').length + 1;
                        const description = meetingCount === 1 ? 'ç¬¬ä¸€æ¬¡ç›¸é‡' : 
                                          meetingCount === 2 ? 'ç¬¬äºŒæ¬¡ç›¸é‡' : 
                                          `ç¬¬${meetingCount}æ¬¡ç›¸é‡`;
                        
                        specialMoments.push({
                            time: meetingTime,
                            type: 'meeting',
                            description: description,
                            color: '#9b59b6'
                        });
                        console.log("æ·»åŠ ç›¸é‡æ—¶åˆ»:", meetingTime, description);
                    }
                }
                
                lastXDiff = xDiff;
            }
        }
        
        // è®¡ç®—è·ç¦»æå€¼æ—¶åˆ» - ä¿®å¤ç‰ˆï¼šæ˜¾ç¤ºä¸¤è½¦ä¹‹é—´çš„è·ç¦»
        function calculateExtremeMoments() {
            console.log("è®¡ç®—è·ç¦»æå€¼æ—¶åˆ»...");
            // è·ç¦»å‡½æ•°ï¼šd(t) = |xA(t) - xB(t)|
            // æå€¼ç‚¹å‡ºç°åœ¨å¯¼æ•°d'(t)=0æˆ–ä¸å¯å¯¼å¤„
            
            const timeStep = 0.1;
            const maxT = getMaxTime();
            let lastDistance = Math.abs(
                calculatePosition('A', 0) - calculatePosition('B', 0)
            );
            let lastDerivative = 0;
            
            for (let t = timeStep; t <= maxT; t += timeStep) {
                const xA = calculatePosition('A', t);
                const xB = calculatePosition('B', t);
                const distance = Math.abs(xA - xB);
                
                // è®¡ç®—å¯¼æ•°ï¼ˆæ•°å€¼å¾®åˆ†ï¼‰
                const derivative = (distance - lastDistance) / timeStep;
                
                // æ£€æŸ¥å¯¼æ•°å˜å·ï¼ˆæå€¼ç‚¹ï¼‰
                if (lastDerivative * derivative < 0 && Math.abs(derivative) < 1) {
                    // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨ç›¸è¿‘çš„æå€¼æ—¶åˆ»
                    const existing = specialMoments.find(
                        m => m.type === 'extreme' && Math.abs(m.time - t) < 0.5
                    );
                    
                    if (!existing) {
                        // è®¡ç®—æå€¼ç‚¹çš„ç²¾ç¡®è·ç¦»
                        const t_before = t - timeStep;
                        const t_after = t + timeStep;
                        const dist_before = Math.abs(
                            calculatePosition('A', t_before) - calculatePosition('B', t_before)
                        );
                        const dist_after = Math.abs(
                            calculatePosition('A', t_after) - calculatePosition('B', t_after)
                        );
                        
                        // åˆ¤æ–­æ˜¯æå¤§å€¼è¿˜æ˜¯æå°å€¼
                        const isMin = distance < dist_before && distance < dist_after;
                        const isMax = distance > dist_before && distance > dist_after;
                        
                        if (isMin || isMax) {
                            const description = isMin ? 
                                `è·ç¦»æœ€å°: ${distance.toFixed(2)} m` : 
                                `è·ç¦»æœ€å¤§: ${distance.toFixed(2)} m`;
                            
                            specialMoments.push({
                                time: t,
                                type: 'extreme',
                                description: description,
                                color: '#f1c40f'
                            });
                            console.log("æ·»åŠ è·ç¦»æå€¼æ—¶åˆ»:", t, description);
                        }
                    }
                }
                
                lastDistance = distance;
                lastDerivative = derivative;
            }
            
            // æ£€æŸ¥åˆå§‹æ—¶åˆ»æ˜¯å¦ä¸ºæå€¼ç‚¹
            let initialXA, initialXB;
            if (currentMode === 'single') {
                initialXA = singleParams.x0A;
                initialXB = singleParams.x0B;
            } else {
                initialXA = multiProcesses[0].params.x0A !== null ? multiProcesses[0].params.x0A : 0;
                initialXB = multiProcesses[0].params.x0B !== null ? multiProcesses[0].params.x0B : 30;
            }
            
            const initialDistance = Math.abs(initialXA - initialXB);
            const t_initial_check = timeStep;
            const dist_initial_check = Math.abs(
                calculatePosition('A', t_initial_check) - calculatePosition('B', t_initial_check)
            );
            
            if (initialDistance > dist_initial_check) {
                // åˆå§‹æ—¶åˆ»å¯èƒ½æ˜¯æå¤§å€¼
                const existing = specialMoments.find(
                    m => m.type === 'extreme' && Math.abs(m.time - 0) < 0.5
                );
                
                if (!existing) {
                    specialMoments.push({
                        time: 0,
                        type: 'extreme',
                        description: `è·ç¦»æœ€å¤§: ${initialDistance.toFixed(2)} m`,
                        color: '#f1c40f'
                    });
                    console.log("æ·»åŠ åˆå§‹æ—¶åˆ»è·ç¦»æå¤§å€¼:", initialDistance);
                }
            }
        }
        
        // ==================== ç•Œé¢æ›´æ–°å‡½æ•° ====================
        
        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStatusDisplay() {
            let t;
            if (currentMode === 'single') {
                t = singleParams.t;
            } else {
                t = singleParams.t; // ä½¿ç”¨å•è¿‡ç¨‹çš„æ—¶é—´ï¼Œä½†éœ€è¦è½¬æ¢ä¸ºå¤šè¿‡ç¨‹æ—¶é—´
            }
            
            const vA = calculateVelocity('A', t);
            const vB = calculateVelocity('B', t);
            const isMovingA = calculateIsMoving('A', t);
            const isMovingB = calculateIsMoving('B', t);
            
            // æ›´æ–°AçŠ¶æ€
            if (!isMovingA) {
                statusA.textContent = 'å·²åœè½¦';
                statusA.className = 'object-status status-stopped';
            } else if (currentMode === 'single' && brakeA.checked && singleParams.aA < 0 && vA > 0) {
                statusA.textContent = 'åˆ¹è½¦ä¸­';
                statusA.className = 'object-status status-braking';
            } else if (currentMode === 'multi') {
                const processInfo = getCurrentProcessInfo(t);
                const currentProcess = multiProcesses[processInfo.processIndex];
                if (currentProcess.params.brakeA && currentProcess.params.aA < 0 && vA > 0) {
                    statusA.textContent = 'åˆ¹è½¦ä¸­';
                    statusA.className = 'object-status status-braking';
                } else {
                    statusA.textContent = 'è¿åŠ¨ä¸­';
                    statusA.className = 'object-status status-moving';
                }
            } else {
                statusA.textContent = 'è¿åŠ¨ä¸­';
                statusA.className = 'object-status status-moving';
            }
            
            // æ›´æ–°BçŠ¶æ€
            if (!isMovingB) {
                statusB.textContent = 'å·²åœè½¦';
                statusB.className = 'object-status status-stopped';
            } else if (currentMode === 'single' && brakeB.checked && singleParams.aB < 0 && vB > 0) {
                statusB.textContent = 'åˆ¹è½¦ä¸­';
                statusB.className = 'object-status status-braking';
            } else if (currentMode === 'multi') {
                const processInfo = getCurrentProcessInfo(t);
                const currentProcess = multiProcesses[processInfo.processIndex];
                if (currentProcess.params.brakeB && currentProcess.params.aB < 0 && vB > 0) {
                    statusB.textContent = 'åˆ¹è½¦ä¸­';
                    statusB.className = 'object-status status-braking';
                } else {
                    statusB.textContent = 'è¿åŠ¨ä¸­';
                    statusB.className = 'object-status status-moving';
                }
            } else {
                statusB.textContent = 'è¿åŠ¨ä¸­';
                statusB.className = 'object-status status-moving';
            }
        }
        
        // æ›´æ–°è¾“å…¥æ§ä»¶
        function updateInputsAndSliders() {
            // å•è¿‡ç¨‹æ¨¡å¼
            singleInputs.x0A.value = singleParams.x0A.toFixed(1);
            singleInputs.v0A.value = singleParams.v0A.toFixed(1);
            singleInputs.aA.value = singleParams.aA.toFixed(1);
            singleInputs.x0B.value = singleParams.x0B.toFixed(1);
            singleInputs.v0B.value = singleParams.v0B.toFixed(1);
            singleInputs.aB.value = singleParams.aB.toFixed(1);
            singleInputs.time.value = singleParams.t.toFixed(1);
            
            singleSliders.x0A.value = singleParams.x0A;
            singleSliders.v0A.value = singleParams.v0A;
            singleSliders.aA.value = singleParams.aA;
            singleSliders.x0B.value = singleParams.x0B;
            singleSliders.v0B.value = singleParams.v0B;
            singleSliders.aB.value = singleParams.aB;
            singleSliders.time.value = singleParams.t;
            
            // å¤šè¿‡ç¨‹æ¨¡å¼ - æ›´æ–°å½“å‰è¿‡ç¨‹çš„æ§ä»¶
            updateMultiProcessControls();
        }
        
        // æ›´æ–°ä¿¡æ¯é¢æ¿
        function updateInfoPanel() {
            let t;
            if (currentMode === 'single') {
                t = singleParams.t;
            } else {
                t = singleParams.t; // ä½¿ç”¨å•è¿‡ç¨‹çš„æ—¶é—´ï¼Œä½†éœ€è¦è½¬æ¢ä¸ºå¤šè¿‡ç¨‹æ—¶é—´
            }
            
            const xA = calculatePosition('A', t);
            const xB = calculatePosition('B', t);
            const vA = calculateVelocity('A', t);
            const vB = calculateVelocity('B', t);
            
            const distance = Math.abs(xA - xB);
            const relativeSpeed = Math.abs(vA - vB);
            
            // è®¡ç®—ä½ç§»ï¼ˆå½“å‰ä½ç½® - åˆå§‹ä½ç½®ï¼‰
            let initialXA, initialXB;
            if (currentMode === 'single') {
                initialXA = singleParams.x0A;
                initialXB = singleParams.x0B;
            } else {
                // å¤šè¿‡ç¨‹æ¨¡å¼ï¼šä½¿ç”¨è¿‡ç¨‹1çš„åˆå§‹ä½ç½®
                initialXA = multiProcesses[0].params.x0A !== null ? multiProcesses[0].params.x0A : 0;
                initialXB = multiProcesses[0].params.x0B !== null ? multiProcesses[0].params.x0B : 30;
            }
            
            const displacementA = xA - initialXA;
            const displacementB = xB - initialXB;
            
            // è®¡ç®—è¿åŠ¨æ—¶é—´ï¼ˆè€ƒè™‘åˆ¹è½¦ï¼‰
            const movementTimeA = calculateMovementTime('A', t);
            const movementTimeB = calculateMovementTime('B', t);
            
            // è®¡ç®—åŠ é€Ÿåº¦
            const accelerationA = calculateAcceleration('A', t);
            const accelerationB = calculateAcceleration('B', t);
            
            // æ›´æ–°æ•°æ®é¡¹
            document.getElementById('distanceValue').textContent = distance.toFixed(2) + ' m';
            document.getElementById('relativeSpeedValue').textContent = relativeSpeed.toFixed(2) + ' m/s';
            document.getElementById('velocityAValue').textContent = vA.toFixed(2) + ' m/s';
            document.getElementById('velocityBValue').textContent = vB.toFixed(2) + ' m/s';
            document.getElementById('displacementAValue').textContent = displacementA.toFixed(2) + ' m';
            document.getElementById('displacementBValue').textContent = displacementB.toFixed(2) + ' m';
            document.getElementById('movementTimeAValue').textContent = movementTimeA.toFixed(2) + ' s';
            document.getElementById('movementTimeBValue').textContent = movementTimeB.toFixed(2) + ' s';
            document.getElementById('accelerationAValue').textContent = accelerationA.toFixed(2) + ' m/sÂ²';
            document.getElementById('accelerationBValue').textContent = accelerationB.toFixed(2) + ' m/sÂ²';
            
            // æ›´æ–°è¿‡ç¨‹ä¿¡æ¯
            const processInfo = getCurrentProcessInfo(t);
            document.getElementById('currentProcessValue').textContent = processInfo.processIndex + 1;
            document.getElementById('processTimeValue').textContent = processInfo.processOffset.toFixed(2) + ' s';
            
            // æ£€æŸ¥ä¸´ç•Œæ¡ä»¶
            checkCriticalConditions();
        }
        
        // æ£€æŸ¥ä¸´ç•Œæ¡ä»¶
        function checkCriticalConditions() {
            let t;
            if (currentMode === 'single') {
                t = singleParams.t;
            } else {
                t = singleParams.t;
            }
            
            const xA = calculatePosition('A', t);
            const xB = calculatePosition('B', t);
            const vA = calculateVelocity('A', t);
            const vB = calculateVelocity('B', t);
            
            let message = '';
            
            // ç›¸é‡
            if (Math.abs(xA - xB) < 0.5) {
                message = 'ğŸ¯ ä¸¤ç‰©ä½“ç›¸é‡ï¼';
            }
            // é€Ÿåº¦ç›¸ç­‰ï¼ˆè·ç¦»æå€¼ï¼‰
            else if (Math.abs(vA - vB) < 0.2) {
                message = 'âš¡ é€Ÿåº¦ç›¸ç­‰ï¼Œè·ç¦»è¾¾åˆ°æå€¼';
            }
            // åœè½¦
            else if (!calculateIsMoving('A', t) && !calculateIsMoving('B', t)) {
                message = 'ğŸ›‘ ä¸¤è½¦å‡å·²åœè½¦';
            }
            else if (!calculateIsMoving('A', t)) {
                message = 'ğŸ›‘ Aè½¦å·²åœè½¦';
            }
            else if (!calculateIsMoving('B', t)) {
                message = 'ğŸ›‘ Bè½¦å·²åœè½¦';
            }
            // è¿‡ç¨‹åˆ‡æ¢
            else if (currentMode === 'multi') {
                const processInfo = getCurrentProcessInfo(t);
                if (Math.abs(processInfo.processOffset) < 0.1 && processInfo.processIndex > 0) {
                    message = `ğŸ”„ åˆ‡æ¢åˆ°è¿‡ç¨‹${processInfo.processIndex + 1}`;
                }
            }
            
            const criticalInfo = document.getElementById('criticalInfo');
            const criticalText = document.getElementById('criticalText');
            
            if (message) {
                criticalText.textContent = message;
                criticalInfo.style.display = 'block';
            } else {
                criticalInfo.style.display = 'none';
            }
        }
        
        // æ›´æ–°å…³é”®æ—¶åˆ»åˆ—è¡¨
        function updateMomentsList() {
            console.log("æ›´æ–°å…³é”®æ—¶åˆ»åˆ—è¡¨ï¼Œå…±", specialMoments.length, "ä¸ªæ—¶åˆ»");
            momentsList.innerHTML = '';
            
            if (specialMoments.length === 0) {
                momentsList.innerHTML = '<div class="moment-item" style="text-align: center; color: #999;">æš‚æ— å…³é”®æ—¶åˆ»</div>';
                return;
            }
            
            let t;
            if (currentMode === 'single') {
                t = singleParams.t;
            } else {
                t = singleParams.t;
            }
            
            specialMoments.forEach((moment, index) => {
                const div = document.createElement('div');
                div.className = 'moment-item';
                if (Math.abs(t - moment.time) < 0.1) {
                    div.classList.add('active');
                }
                
                div.innerHTML = `
                    <div class="moment-time">
                        <span>t = ${moment.time.toFixed(2)} s</span>
                        <span style="color: ${moment.color};">${moment.type === 'stop' ? 'ğŸ›‘' : moment.type === 'meeting' ? 'ğŸ¤' : moment.type === 'extreme' ? 'ğŸ“Š' : moment.type === 'process' ? 'ğŸ”„' : 'ğŸ“'}</span>
                    </div>
                    <div class="moment-description">${moment.description}</div>
                `;
                
                div.addEventListener('click', () => {
                    if (currentMode === 'single') {
                        singleParams.t = moment.time;
                        singleSliders.time.value = moment.time;
                        singleInputs.time.value = moment.time.toFixed(1);
                    } else {
                        singleParams.t = moment.time;
                        // å¤šè¿‡ç¨‹æ¨¡å¼ä¹Ÿéœ€è¦æ›´æ–°æ—¶é—´ï¼Œä½†ä¸éœ€è¦æ›´æ–°æ»‘å—ï¼ˆå› ä¸ºæ»‘å—æ˜¯å•è¿‡ç¨‹çš„ï¼‰
                        // æˆ‘ä»¬å¯ä»¥è€ƒè™‘åœ¨å¤šè¿‡ç¨‹æ¨¡å¼ä¸‹ä¹Ÿæ˜¾ç¤ºæ—¶é—´æ»‘å—
                    }
                    stopAnimation();
                    drawMotion();
                    updateCharts();
                    updateInfoPanel();
                    updateMomentsList();
                });
                
                momentsList.appendChild(div);
            });
        }
        
        // ç»˜åˆ¶è¿‡ç¨‹æ ‡è®°
        function drawProcessMarkers() {
            if (!document.getElementById('showProcessMarkers').checked || currentMode === 'single') {
                processMarkers.innerHTML = '';
                return;
            }
            
            const width = canvas.width;
            const height = canvas.height;
            let html = '';
            
            // è®¡ç®—æ€»æ—¶é—´
            const totalTime = getMaxTime();
            
            // ç»˜åˆ¶æ¯ä¸ªè¿‡ç¨‹çš„æ ‡è®°
            let accumulatedTime = 0;
            multiProcesses.forEach((process, index) => {
                // è®¡ç®—æ ‡è®°ä½ç½®
                const x = 50 + (accumulatedTime / totalTime) * (width - 100);
                
                // æ·»åŠ æ ‡è®°çº¿
                html += `<div class="process-marker-line" style="left: ${x}px;"></div>`;
                
                // æ·»åŠ æ ‡è®°æ–‡æœ¬
                html += `<div class="process-marker" style="left: ${x}px;">è¿‡ç¨‹${index + 1}<br>${accumulatedTime.toFixed(1)}s</div>`;
                
                accumulatedTime += process.duration;
            });
            
            // æ·»åŠ æœ€åä¸€ä¸ªæ ‡è®°
            const x = 50 + (accumulatedTime / totalTime) * (width - 100);
            html += `<div class="process-marker-line" style="left: ${x}px;"></div>`;
            html += `<div class="process-marker" style="left: ${x}px;">ç»“æŸ<br>${accumulatedTime.toFixed(1)}s</div>`;
            
            processMarkers.innerHTML = html;
        }
        
        // ==================== ç»˜å›¾å‡½æ•° ====================
        
        // ç»˜åˆ¶è¿åŠ¨è§†å›¾
        function drawMotion() {
            const width = canvas.width;
            const height = canvas.height;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, width, height);
            
            // ç»˜åˆ¶åæ ‡è½´
            drawAxes();
            
            // è®¡ç®—å½“å‰ä½ç½®
            let t;
            if (currentMode === 'single') {
                t = singleParams.t;
            } else {
                t = singleParams.t;
            }
            
            const xA = calculatePosition('A', t);
            const xB = calculatePosition('B', t);
            const vA = calculateVelocity('A', t);
            const vB = calculateVelocity('B', t);
            
            // ç»˜åˆ¶è½¨è¿¹
            if (document.getElementById('showTrajectory').checked) {
                drawTrajectory();
            }
            
            // ç»˜åˆ¶å…³é”®æ—¶åˆ»æ ‡è®°
            if (document.getElementById('showAllMoments').checked) {
                drawMomentMarkers();
            }
            
            // ç»˜åˆ¶åœè½¦ä½ç½®
            if (document.getElementById('showStopPosition').checked) {
                if (objectStates.A.stopPosition !== null) {
                    drawStopPosition(objectStates.A.stopPosition, '#3498db', 'A');
                }
                if (objectStates.B.stopPosition !== null) {
                    drawStopPosition(objectStates.B.stopPosition, '#e74c3c', 'B');
                }
            }
            
            // ç»˜åˆ¶ç‰©ä½“
            drawObject(xA, height/2, '#3498db', 'A', vA, calculateIsMoving('A', t));
            drawObject(xB, height/2, '#e74c3c', 'B', vB, calculateIsMoving('B', t));
            
            // ç»˜åˆ¶è·ç¦»çº¿
            drawDistanceLine(xA, xB, height/2);
            
            // ç»˜åˆ¶æ—¶é—´æŒ‡ç¤ºå™¨
            drawTimeIndicator();
            
            // ç»˜åˆ¶è¿‡ç¨‹æ ‡è®°
            drawProcessMarkers();
            
            // ç»˜åˆ¶æ¯”ä¾‹å°º
            drawScaleBar();
            
            // æ›´æ–°è§†å›¾ä¿¡æ¯
            updateViewInfo();
        }
        
        // ç»˜åˆ¶åæ ‡è½´
        function drawAxes() {
            const width = canvas.width;
            const height = canvas.height;
            
            // è·å–å½“å‰è§†å›¾èŒƒå›´
            const range = getViewRange();
            const minX = range.minX;
            const maxX = range.maxX;
            const rangeWidth = maxX - minX;
            
            // xè½´ï¼ˆä½ç½®è½´ï¼‰
            ctx.beginPath();
            ctx.moveTo(50, height/2);
            ctx.lineTo(width - 50, height/2);
            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // åˆ»åº¦ï¼ˆåŠ¨æ€è°ƒæ•´åˆ»åº¦å¯†åº¦ï¼‰
            ctx.font = '14px Arial';
            ctx.fillStyle = '#7f8c8d';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            // æ ¹æ®èŒƒå›´å¤§å°è°ƒæ•´åˆ»åº¦é—´éš”
            let tickInterval = 20;
            if (rangeWidth > 1000) tickInterval = 200;
            else if (rangeWidth > 500) tickInterval = 100;
            else if (rangeWidth > 200) tickInterval = 50;
            else if (rangeWidth > 100) tickInterval = 20;
            else if (rangeWidth > 50) tickInterval = 10;
            else if (rangeWidth > 20) tickInterval = 5;
            else tickInterval = 2;
            
            // è®¡ç®—ç¬¬ä¸€ä¸ªåˆ»åº¦ä½ç½®
            const firstTick = Math.ceil(minX / tickInterval) * tickInterval;
            
            for (let x = firstTick; x <= maxX; x += tickInterval) {
                const canvasX = positionToCanvasX(x);
                
                // ç¡®ä¿åˆ»åº¦åœ¨ç”»å¸ƒå†…
                if (canvasX >= 50 && canvasX <= width - 50) {
                    ctx.beginPath();
                    ctx.moveTo(canvasX, height/2 - 5);
                    ctx.lineTo(canvasX, height/2 + 5);
                    ctx.stroke();
                    
                    // æ˜¾ç¤ºåˆ»åº¦å€¼ï¼ˆæ ¼å¼åŒ–å¤§æ•°å­—ï¼‰
                    let displayText = x.toString();
                    if (Math.abs(x) >= 1000) {
                        displayText = (x / 1000).toFixed(1) + 'k';
                    }
                    
                    ctx.fillText(displayText, canvasX, height/2 + 10);
                }
            }
            
            // æ ‡ç­¾
            ctx.font = 'bold 16px Arial';
            ctx.fillText('ä½ç½® x (m)', width - 30, height/2 - 20);
            
            // æ—¶é—´è½´ï¼ˆé¡¶éƒ¨ï¼‰
            const maxT = getMaxTime();
            ctx.beginPath();
            ctx.moveTo(50, 30);
            ctx.lineTo(width - 50, 30);
            ctx.strokeStyle = '#95a5a6';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // æ—¶é—´åˆ»åº¦
            ctx.font = '12px Arial';
            ctx.fillStyle = '#95a5a6';
            
            let timeTickInterval = 2;
            if (maxT > 50) timeTickInterval = 10;
            else if (maxT > 20) timeTickInterval = 5;
            else if (maxT > 10) timeTickInterval = 2;
            else timeTickInterval = 1;
            
            for (let t = 0; t <= maxT; t += timeTickInterval) {
                const canvasX = 50 + (t / maxT) * (width - 100);
                ctx.beginPath();
                ctx.moveTo(canvasX, 25);
                ctx.lineTo(canvasX, 35);
                ctx.stroke();
                ctx.fillText(t.toString(), canvasX, 40);
            }
            
            // æ—¶é—´æ ‡ç­¾
            ctx.fillText('æ—¶é—´ t (s)', width/2, 60);
        }
        
        // ç»˜åˆ¶ç‰©ä½“
        function drawObject(x, y, color, label, velocity, isMoving) {
            const scaledX = positionToCanvasX(x);
            
            // è½¦èº«
            ctx.beginPath();
            const carWidth = Math.max(20, Math.min(30, 30 * (200 / (getViewRange().maxX - getViewRange().minX))));
            ctx.rect(scaledX - carWidth/2, y - 10, carWidth, 20);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // è½¦è½®
            const wheelSize = Math.max(3, Math.min(5, 5 * (200 / (getViewRange().maxX - getViewRange().minX))));
            ctx.beginPath();
            ctx.arc(scaledX - carWidth/4, y + 10, wheelSize, 0, Math.PI * 2);
            ctx.arc(scaledX + carWidth/4, y + 10, wheelSize, 0, Math.PI * 2);
            ctx.fillStyle = '#2c3e50';
            ctx.fill();
            
            // æ ‡ç­¾
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(label, scaledX, y);
            
            // é€Ÿåº¦æ˜¾ç¤º
            if (document.getElementById('showVelocity').checked) {
                ctx.font = 'bold 14px Arial';
                ctx.fillStyle = color;
                ctx.fillText(`v=${velocity.toFixed(2)}`, scaledX, y - 25);
            }
            
            // åˆ¹è½¦ç¯
            let brakeEnabled = false;
            let a = 0;
            
            if (currentMode === 'single') {
                brakeEnabled = label === 'A' ? brakeA.checked : brakeB.checked;
                a = label === 'A' ? singleParams.aA : singleParams.aB;
            } else {
                let t;
                if (currentMode === 'single') {
                    t = singleParams.t;
                } else {
                    t = singleParams.t;
                }
                const processInfo = getCurrentProcessInfo(t);
                const currentProcess = multiProcesses[processInfo.processIndex];
                brakeEnabled = label === 'A' ? currentProcess.params.brakeA : currentProcess.params.brakeB;
                a = label === 'A' ? currentProcess.params.aA : currentProcess.params.aB;
            }
            
            if (document.getElementById('showBrakeLight').checked && brakeEnabled && a < 0 && velocity > 0) {
                ctx.save();
                ctx.fillStyle = '#e74c3c';
                
                // å·¦ç¯
                ctx.beginPath();
                ctx.arc(scaledX - carWidth/3, y + 5, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // å³ç¯
                ctx.beginPath();
                ctx.arc(scaledX + carWidth/3, y + 5, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // é—ªçƒæ•ˆæœ
                if (Math.floor(Date.now() / 200) % 2 === 0) {
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    ctx.arc(scaledX - carWidth/3, y + 5, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(scaledX + carWidth/3, y + 5, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            }
            
            // åœè½¦æ ‡å¿—
            if (!isMoving) {
                ctx.beginPath();
                ctx.arc(scaledX, y - 15, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#e74c3c';
                ctx.fill();
                ctx.font = 'bold 12px Arial';
                ctx.fillStyle = 'white';
                ctx.fillText('åœ', scaledX, y - 15);
            }
            
            // ä½ç½®æ ‡è®°
            ctx.beginPath();
            ctx.moveTo(scaledX, y + 15);
            ctx.lineTo(scaledX, canvas.height - 30);
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = color + '80';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);
            
            // ä½ç½®å€¼
            ctx.font = '14px Arial';
            ctx.fillStyle = color;
            
            let positionText = `x=${x.toFixed(2)}`;
            if (Math.abs(x) >= 1000) {
                positionText = `x=${(x/1000).toFixed(2)}k`;
            }
            
            ctx.fillText(positionText, scaledX, canvas.height - 15);
        }
        
        // ç»˜åˆ¶åœè½¦ä½ç½®
        function drawStopPosition(x, color, label) {
            const width = canvas.width;
            const height = canvas.height;
            const scaledX = positionToCanvasX(x);
            
            ctx.beginPath();
            ctx.moveTo(scaledX, height/2 - 60);
            ctx.lineTo(scaledX, height/2 + 60);
            ctx.strokeStyle = color + '40';
            ctx.lineWidth = 2;
            ctx.setLineDash([3, 3]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.beginPath();
            ctx.arc(scaledX, height/2 - 70, 8, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            
            ctx.font = 'bold 12px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('åœ', scaledX, height/2 - 70);
            
            ctx.font = '12px Arial';
            ctx.fillStyle = color;
            ctx.fillText(`${label}è½¦åœè½¦ä½ç½®`, scaledX, height/2 - 85);
        }
        
        // ç»˜åˆ¶å…³é”®æ—¶åˆ»æ ‡è®°
        function drawMomentMarkers() {
            const width = canvas.width;
            const height = canvas.height;
            const maxT = getMaxTime();
            
            specialMoments.forEach(moment => {
                const xA = calculatePosition('A', moment.time);
                const scaledXA = positionToCanvasX(xA);
                
                // è®¡ç®—æ—¶é—´æ ‡è®°ä½ç½®ï¼ˆåœ¨æ—¶é—´è½´ä¸Šï¼‰
                const timeX = 50 + (moment.time / maxT) * (width - 100);
                
                // å‚ç›´çº¿
                ctx.beginPath();
                ctx.moveTo(timeX, 30);
                ctx.lineTo(timeX, height/2 - 20);
                ctx.strokeStyle = moment.color + '80';
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // æ—¶é—´æ ‡ç­¾
                ctx.font = '12px Arial';
                ctx.fillStyle = moment.color;
                ctx.textAlign = 'center';
                ctx.fillText(`t=${moment.time.toFixed(2)}`, timeX, 15);
                
                // å›¾æ ‡
                if (moment.type === 'meeting' || moment.type === 'stop' || moment.type === 'process') {
                    ctx.beginPath();
                    ctx.arc(timeX, height/2 - 60, 8, 0, Math.PI * 2);
                    ctx.fillStyle = moment.color;
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    ctx.font = 'bold 12px Arial';
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    let symbol = '';
                    if (moment.type === 'meeting') symbol = 'ç¢°';
                    else if (moment.type === 'stop') symbol = 'åœ';
                    else if (moment.type === 'process') symbol = 'P';
                    ctx.fillText(symbol, timeX, height/2 - 58);
                }
            });
        }
        
        // ç»˜åˆ¶è½¨è¿¹
        function drawTrajectory() {
            const width = canvas.width;
            const height = canvas.height;
            const maxT = getMaxTime();
            
            // Aè½¨è¿¹
            ctx.beginPath();
            const step = maxT / 200; // æ ¹æ®æ€»æ—¶é—´è°ƒæ•´æ­¥é•¿
            for (let t = 0; t <= maxT; t += step) {
                const x = calculatePosition('A', t);
                const scaledX = positionToCanvasX(x);
                const scaledY = height/2 - 30;
                if (t === 0) ctx.moveTo(scaledX, scaledY);
                else ctx.lineTo(scaledX, scaledY);
            }
            ctx.strokeStyle = '#3498db80';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Bè½¨è¿¹
            ctx.beginPath();
            for (let t = 0; t <= maxT; t += step) {
                const x = calculatePosition('B', t);
                const scaledX = positionToCanvasX(x);
                const scaledY = height/2 - 50;
                if (t === 0) ctx.moveTo(scaledX, scaledY);
                else ctx.lineTo(scaledX, scaledY);
            }
            ctx.strokeStyle = '#e74c3c80';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        // ç»˜åˆ¶è·ç¦»çº¿
        function drawDistanceLine(xA, xB, y) {
            const scaledXA = positionToCanvasX(xA);
            const scaledXB = positionToCanvasX(xB);
            const midX = (scaledXA + scaledXB) / 2;
            const distance = Math.abs(xA - xB);
            
            ctx.beginPath();
            ctx.moveTo(scaledXA, y - 25);
            ctx.lineTo(scaledXB, y - 25);
            ctx.setLineDash([5, 3]);
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.font = 'bold 14px Arial';
            ctx.fillStyle = '#2c3e50';
            ctx.textAlign = 'center';
            
            let distanceText = `${distance.toFixed(2)} m`;
            if (distance >= 1000) {
                distanceText = `${(distance/1000).toFixed(2)} km`;
            }
            
            ctx.fillText(`è·ç¦»: ${distanceText}`, midX, y - 40);
        }
        
        // ç»˜åˆ¶æ—¶é—´æŒ‡ç¤ºå™¨
        function drawTimeIndicator() {
            let t;
            if (currentMode === 'single') {
                t = singleParams.t;
            } else {
                t = singleParams.t;
            }
            
            const processInfo = getCurrentProcessInfo(t);
            
            ctx.font = 'bold 18px Arial';
            ctx.fillStyle = '#2c3e50';
            ctx.textAlign = 'left';
            ctx.fillText(`æ—¶é—´ t = ${t.toFixed(2)} s`, 20, 80);
            
            if (currentMode === 'multi') {
                ctx.font = '14px Arial';
                ctx.fillText(`è¿‡ç¨‹ ${processInfo.processIndex + 1} (${processInfo.processOffset.toFixed(2)}/${multiProcesses[processInfo.processIndex].duration.toFixed(2)} s)`, 20, 105);
            }
        }
        
        // ç»˜åˆ¶æ¯”ä¾‹å°º
        function drawScaleBar() {
            if (!document.getElementById('showScaleIndicator').checked) {
                return;
            }
            
            const range = getViewRange();
            const rangeWidth = range.maxX - range.minX;
            const width = canvas.width;
            const height = canvas.height;
            
            // è®¡ç®—åˆé€‚çš„æ¯”ä¾‹å°ºé•¿åº¦ï¼ˆåƒç´ ï¼‰
            const canvasWidth = width - 100; // å‡å»è¾¹è·
            let targetMeters = 100; // é»˜è®¤ç›®æ ‡æ˜¾ç¤º100ç±³
            
            // æ ¹æ®èŒƒå›´è°ƒæ•´æ¯”ä¾‹å°ºé•¿åº¦
            if (rangeWidth > 1000) targetMeters = 500;
            if (rangeWidth > 5000) targetMeters = 1000;
            if (rangeWidth > 10000) targetMeters = 2000;
            if (rangeWidth > 20000) targetMeters = 5000;
            
            // ç¡®ä¿æ¯”ä¾‹å°ºä¸ä¼šå¤ªé•¿
            targetMeters = Math.min(targetMeters, rangeWidth * 0.3);
            
            // è®¡ç®—åƒç´ é•¿åº¦
            const pixelLength = (targetMeters / rangeWidth) * canvasWidth;
            
            // ç¡®ä¿æ¯”ä¾‹å°ºä¸ä¼šå¤ªçŸ­
            if (pixelLength < 50) {
                targetMeters = (50 / canvasWidth) * rangeWidth;
            }
            
            // ç»˜åˆ¶æ¯”ä¾‹å°ºèƒŒæ™¯
            const scaleX = width - pixelLength - 60;
            const scaleY = height - 40;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillRect(scaleX - 5, scaleY - 5, pixelLength + 10, 30);
            ctx.strokeStyle = '#7f8c8d';
            ctx.lineWidth = 1;
            ctx.strokeRect(scaleX - 5, scaleY - 5, pixelLength + 10, 30);
            
            // ç»˜åˆ¶æ¯”ä¾‹å°º
            ctx.beginPath();
            ctx.moveTo(scaleX, scaleY + 10);
            ctx.lineTo(scaleX + pixelLength, scaleY + 10);
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // åˆ»åº¦
            ctx.beginPath();
            ctx.moveTo(scaleX, scaleY);
            ctx.lineTo(scaleX, scaleY + 20);
            ctx.moveTo(scaleX + pixelLength, scaleY);
            ctx.lineTo(scaleX + pixelLength, scaleY + 20);
            ctx.strokeStyle = '#2c3e50';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // æ ‡æ³¨
            ctx.font = '12px Arial';
            ctx.fillStyle = '#2c3e50';
            ctx.textAlign = 'center';
            
            let scaleText = `${targetMeters.toFixed(0)} m`;
            if (targetMeters >= 1000) {
                scaleText = `${(targetMeters / 1000).toFixed(1)} km`;
            }
            
            ctx.fillText(scaleText, scaleX + pixelLength/2, scaleY + 25);
        }
        
        // ==================== å›¾è¡¨å‡½æ•° ====================
        
        // åˆå§‹åŒ–å›¾è¡¨
        function initCharts() {
            // s-tå›¾
            sChart = echarts.init(document.getElementById('sChart'));
            sChart.setOption({
                backgroundColor: '#f8f9fa',
                grid: { left: '12%', right: '8%', top: '15%', bottom: '15%' },
                xAxis: {
                    type: 'value',
                    name: 'æ—¶é—´ t (s)',
                    min: 0,
                    max: 20,
                    splitLine: { show: true }
                },
                yAxis: {
                    type: 'value',
                    name: 'ä½ç§» x (m)',
                    splitLine: { show: true }
                },
                series: [
                    {
                        name: 'ç‰©ä½“A',
                        type: 'line',
                        smooth: true,
                        lineStyle: { width: 3, color: '#3498db' },
                        symbol: 'none'
                    },
                    {
                        name: 'ç‰©ä½“B',
                        type: 'line',
                        smooth: true,
                        lineStyle: { width: 3, color: '#e74c3c' },
                        symbol: 'none'
                    }
                ],
                tooltip: {
                    trigger: 'axis',
                    formatter: params => {
                        let result = 'æ—¶é—´: ' + params[0].axisValue + ' s<br/>';
                        params.forEach(p => {
                            result += p.marker + p.seriesName + ': ' + p.data[1].toFixed(2) + ' m<br/>';
                        });
                        return result;
                    }
                }
            });
            
            // v-tå›¾
            vChart = echarts.init(document.getElementById('vChart'));
            vChart.setOption({
                backgroundColor: '#f8f9fa',
                grid: { left: '12%', right: '8%', top: '15%', bottom: '15%' },
                xAxis: {
                    type: 'value',
                    name: 'æ—¶é—´ t (s)',
                    min: 0,
                    max: 20,
                    splitLine: { show: true }
                },
                yAxis: {
                    type: 'value',
                    name: 'é€Ÿåº¦ v (m/s)',
                    splitLine: { show: true }
                },
                series: [
                    {
                        name: 'ç‰©ä½“A',
                        type: 'line',
                        smooth: true,
                        lineStyle: { width: 3, color: '#3498db' },
                        symbol: 'none'
                    },
                    {
                        name: 'ç‰©ä½“B',
                        type: 'line',
                        smooth: true,
                        lineStyle: { width: 3, color: '#e74c3c' },
                        symbol: 'none'
                    }
                ],
                tooltip: {
                    trigger: 'axis',
                    formatter: params => {
                        let result = 'æ—¶é—´: ' + params[0].axisValue + ' s<br/>';
                        params.forEach(p => {
                            result += p.marker + p.seriesName + ': ' + p.data[1].toFixed(2) + ' m/s<br/>';
                        });
                        return result;
                    }
                }
            });
            
            // a-tå›¾
            aChart = echarts.init(document.getElementById('aChart'));
            aChart.setOption({
                backgroundColor: '#f8f9fa',
                grid: { left: '12%', right: '8%', top: '15%', bottom: '15%' },
                xAxis: {
                    type: 'value',
                    name: 'æ—¶é—´ t (s)',
                    min: 0,
                    max: 20,
                    splitLine: { show: true }
                },
                yAxis: {
                    type: 'value',
                    name: 'åŠ é€Ÿåº¦ a (m/sÂ²)',
                    splitLine: { show: true }
                },
                series: [
                    {
                        name: 'ç‰©ä½“A',
                        type: 'line',
                        smooth: true,
                        lineStyle: { width: 3, color: '#3498db' },
                        symbol: 'none'
                    },
                    {
                        name: 'ç‰©ä½“B',
                        type: 'line',
                        smooth: true,
                        lineStyle: { width: 3, color: '#e74c3c' },
                        symbol: 'none'
                    }
                ],
                tooltip: {
                    trigger: 'axis',
                    formatter: params => {
                        let result = 'æ—¶é—´: ' + params[0].axisValue + ' s<br/>';
                        params.forEach(p => {
                            result += p.marker + p.seriesName + ': ' + p.data[1].toFixed(2) + ' m/sÂ²<br/>';
                        });
                        return result;
                    }
                }
            });
            
            // d-tå›¾ï¼ˆè·ç¦»-æ—¶é—´å›¾ï¼‰
            dChart = echarts.init(document.getElementById('dChart'));
            dChart.setOption({
                backgroundColor: '#f8f9fa',
                grid: { left: '12%', right: '8%', top: '15%', bottom: '15%' },
                xAxis: {
                    type: 'value',
                    name: 'æ—¶é—´ t (s)',
                    min: 0,
                    max: 20,
                    splitLine: { show: true }
                },
                yAxis: {
                    type: 'value',
                    name: 'è·ç¦» d (m)',
                    splitLine: { show: true }
                },
                series: [
                    {
                        name: 'ä¸¤è½¦è·ç¦»',
                        type: 'line',
                        smooth: true,
                        lineStyle: { width: 3, color: '#9b59b6' },
                        symbol: 'none',
                        areaStyle: {
                            color: {
                                type: 'linear',
                                x: 0, y: 0, x2: 0, y2: 1,
                                colorStops: [{
                                    offset: 0, color: '#9b59b640'
                                }, {
                                    offset: 1, color: '#9b59b610'
                                }]
                            }
                        }
                    }
                ],
                tooltip: {
                    trigger: 'axis',
                    formatter: params => {
                        let result = 'æ—¶é—´: ' + params[0].axisValue + ' s<br/>';
                        params.forEach(p => {
                            result += p.marker + p.seriesName + ': ' + p.data[1].toFixed(2) + ' m<br/>';
                        });
                        return result;
                    }
                }
            });
        }
        
        // æ›´æ–°å›¾è¡¨
        function updateCharts() {
            // ç”Ÿæˆæ•°æ®
            const maxT = getMaxTime();
            const sDataA = [], sDataB = [];
            const vDataA = [], vDataB = [];
            const aDataA = [], aDataB = [];
            const dData = [];
            
            const step = maxT / 200;
            for (let t = 0; t <= maxT; t += step) {
                sDataA.push([t, calculatePosition('A', t)]);
                sDataB.push([t, calculatePosition('B', t)]);
                vDataA.push([t, calculateVelocity('A', t)]);
                vDataB.push([t, calculateVelocity('B', t)]);
                dData.push([t, calculateDistance(t)]);
                
                // åŠ é€Ÿåº¦æ•°æ®ï¼ˆè€ƒè™‘åˆ¹è½¦å’Œå¤šè¿‡ç¨‹ï¼‰
                let aA = 0, aB = 0;
                
                if (currentMode === 'single') {
                    aA = singleParams.aA;
                    aB = singleParams.aB;
                    if (brakeA.checked && t >= objectStates.A.stopTime) aA = 0;
                    if (brakeB.checked && t >= objectStates.B.stopTime) aB = 0;
                } else {
                    // å¤šè¿‡ç¨‹æ¨¡å¼
                    const processInfo = getCurrentProcessInfo(t);
                    const currentProcess = multiProcesses[processInfo.processIndex];
                    aA = currentProcess.params.aA;
                    aB = currentProcess.params.aB;
                    
                    if (currentProcess.params.brakeA && t >= objectStates.A.stopTime) aA = 0;
                    if (currentProcess.params.brakeB && t >= objectStates.B.stopTime) aB = 0;
                }
                
                aDataA.push([t, aA]);
                aDataB.push([t, aB]);
            }
            
            // æ›´æ–°å›¾è¡¨
            sChart.setOption({ 
                xAxis: { max: maxT },
                series: [{ data: sDataA }, { data: sDataB }] 
            });
            vChart.setOption({ 
                xAxis: { max: maxT },
                series: [{ data: vDataA }, { data: vDataB }] 
            });
            aChart.setOption({ 
                xAxis: { max: maxT },
                series: [{ data: aDataA }, { data: aDataB }] 
            });
            dChart.setOption({ 
                xAxis: { max: maxT },
                series: [{ data: dData }] 
            });
        }
        
        // ==================== åŠ¨ç”»æ§åˆ¶ ====================
        
        // å¼€å§‹åŠ¨ç”»
        function startAnimation() {
            if (isPlaying) return;
            
            isPlaying = true;
            playBtn.disabled = true;
            pauseBtn.disabled = false;
            lastTimestamp = performance.now();
            
            function animate(timestamp) {
                if (!isPlaying) return;
                
                const deltaTime = (timestamp - lastTimestamp) / 1000;
                lastTimestamp = timestamp;
                
                // æ›´æ–°æ—¶é—´
                const maxT = getMaxTime();
                singleParams.t = Math.min(maxT, singleParams.t + deltaTime * animationSpeed);
                
                // æ›´æ–°å•è¿‡ç¨‹æ¨¡å¼æ§ä»¶
                singleSliders.time.value = singleParams.t;
                singleInputs.time.value = singleParams.t.toFixed(1);
                
                // æ›´æ–°æ˜¾ç¤º
                drawMotion();
                updateCharts();
                updateInfoPanel();
                updateStatusDisplay();
                
                // æ›´æ–°å…³é”®æ—¶åˆ»åˆ—è¡¨é«˜äº®
                updateMomentsListHighlight();
                
                if (singleParams.t < maxT) {
                    animationId = requestAnimationFrame(animate);
                } else {
                    stopAnimation();
                }
            }
            
            animationId = requestAnimationFrame(animate);
        }
        
        // åœæ­¢åŠ¨ç”»
        function stopAnimation() {
            isPlaying = false;
            playBtn.disabled = false;
            pauseBtn.disabled = true;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
        
        // é‡ç½®åŠ¨ç”»ï¼ˆå®Œå…¨æ¸…ç©ºï¼‰
        function resetAnimation() {
            stopAnimation();
            
            // é‡ç½®å•è¿‡ç¨‹å‚æ•°
            singleParams = {
                x0A: 0,
                v0A: 10,
                aA: 0,
                x0B: 30,
                v0B: 5,
                aB: 0,
                t: 0,
                maxT: 50
            };
            
            // é‡ç½®å¤šè¿‡ç¨‹
            resetMultiProcess();
            
            // é‡ç½®è§†å›¾æ§åˆ¶
            resetView();
            
            // é‡ç½®å¤é€‰æ¡†
            brakeA.checked = false;
            brakeB.checked = false;
            document.getElementById('showAllMoments').checked = true;
            document.getElementById('showVelocity').checked = true;
            document.getElementById('showTrajectory').checked = true;
            document.getElementById('showStopPosition').checked = true;
            document.getElementById('showBrakeLight').checked = true;
            document.getElementById('showProcessMarkers').checked = true;
            document.getElementById('showScaleIndicator').checked = true;
            
            // æ›´æ–°æ§ä»¶
            updateInputsAndSliders();
            
            // é‡æ–°è®¡ç®—
            calculateSpecialMoments();
            
            // æ›´æ–°æ˜¾ç¤º
            drawMotion();
            updateCharts();
            updateInfoPanel();
            updateMomentsList();
        }
        
        // å›åˆ°èµ·ç‚¹ï¼ˆä»…é‡ç½®æ—¶é—´ï¼Œä¸æ”¹å˜å…¶ä»–å‚æ•°ï¼‰
        function backToStart() {
            stopAnimation();
            
            singleParams.t = 0;
            singleSliders.time.value = 0;
            singleInputs.time.value = '0';
            
            // æ›´æ–°æ˜¾ç¤º
            drawMotion();
            updateCharts();
            updateInfoPanel();
            updateMomentsList();
        }
        
        // æ›´æ–°å…³é”®æ—¶åˆ»åˆ—è¡¨é«˜äº®
        function updateMomentsListHighlight() {
            let t;
            if (currentMode === 'single') {
                t = singleParams.t;
            } else {
                t = singleParams.t;
            }
            
            document.querySelectorAll('.moment-item').forEach((item, index) => {
                const moment = specialMoments[index];
                if (moment && Math.abs(t - moment.time) < 0.1) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
        }
        
        // ==================== å·¥å…·å‡½æ•° ====================
        
        // æ”¹å˜å•è¿‡ç¨‹å‚æ•°å€¼
        function changeValue(param, delta) {
            singleParams[param] += delta;
            
            // é™åˆ¶èŒƒå›´
            if (param.startsWith('x0')) {
                singleParams[param] = Math.max(-200, Math.min(400, singleParams[param]));
            } else if (param.startsWith('v0')) {
                singleParams[param] = Math.max(0, Math.min(50, singleParams[param]));
            } else if (param.startsWith('a')) {
                singleParams[param] = Math.max(-5, Math.min(5, singleParams[param]));
            } else if (param === 't') {
                singleParams[param] = Math.max(0, Math.min(singleParams.maxT, singleParams[param]));
            }
            
            // æ›´æ–°æ§ä»¶
            singleInputs[param].value = singleParams[param].toFixed(1);
            singleSliders[param].value = singleParams[param];
            
            // é‡æ–°è®¡ç®—
            calculateSpecialMoments();
            
            // åœæ­¢åŠ¨ç”»
            stopAnimation();
            
            // æ›´æ–°æ˜¾ç¤º
            drawMotion();
            updateCharts();
            updateInfoPanel();
            updateMomentsList();
        }
        
        // æ”¹å˜å¤šè¿‡ç¨‹å‚æ•°å€¼
        function changeMultiValue(param, delta) {
            const process = multiProcesses[currentProcessIndex];
            
            if (param === 'duration') {
                process.duration = Math.max(1, Math.min(30, process.duration + delta));
                multiInputs.duration.value = process.duration.toFixed(1);
                multiSliders.duration.value = process.duration;
            } else if (param === 'x0A' || param === 'x0B') {
                // åˆå§‹ä½ç½®ï¼ˆä»…è¿‡ç¨‹1æœ‰æ•ˆï¼‰
                if (currentProcessIndex === 0) {
                    process.params[param] += delta;
                    
                    // é™åˆ¶èŒƒå›´
                    process.params[param] = Math.max(-200, Math.min(400, process.params[param]));
                    
                    // æ›´æ–°æ§ä»¶
                    multiInputs[param].value = process.params[param].toFixed(1);
                    multiSliders[param].value = process.params[param];
                }
            } else {
                process.params[param] += delta;
                
                // é™åˆ¶èŒƒå›´
                if (param.startsWith('v0')) {
                    process.params[param] = Math.max(0, Math.min(50, process.params[param]));
                } else if (param.startsWith('a')) {
                    process.params[param] = Math.max(-5, Math.min(5, process.params[param]));
                }
                
                // æ›´æ–°æ§ä»¶
                multiInputs[param].value = process.params[param].toFixed(1);
                multiSliders[param].value = process.params[param];
            }
            
            // é‡æ–°è®¡ç®—
            calculateProcessStates();
            calculateSpecialMoments();
            
            // åœæ­¢åŠ¨ç”»
            stopAnimation();
            
            // æ›´æ–°æ˜¾ç¤º
            drawMotion();
            updateCharts();
            updateInfoPanel();
            updateMomentsList();
        }
        
        // éšæœºç”Ÿæˆ
        function randomGenerate() {
            stopAnimation();
            
            if (currentMode === 'single') {
                // éšæœºå‚æ•°
                singleParams.x0A = Math.floor(Math.random() * 200) - 100; // -100åˆ°100
                singleParams.v0A = 5 + Math.random() * 20; // 5åˆ°25
                singleParams.aA = (Math.random() > 0.5 ? 1 : -1) * Math.random() * 3;
                
                singleParams.x0B = singleParams.x0A + 20 + Math.random() * 100; // åœ¨Aåé¢20-120ç±³
                singleParams.v0B = Math.max(1, singleParams.v0A - 5 + Math.random() * 15);
                singleParams.aB = (Math.random() > 0.5 ? 1 : -1) * Math.random() * 2;
                
                // éšæœºåˆ¹è½¦
                brakeA.checked = Math.random() > 0.5;
                brakeB.checked = Math.random() > 0.5;
            } else {
                // éšæœºç”Ÿæˆå¤šè¿‡ç¨‹
                const numProcesses = Math.floor(Math.random() * 3) + 2; // 2-4ä¸ªè¿‡ç¨‹
                multiProcesses = [];
                
                for (let i = 0; i < numProcesses; i++) {
                    if (i === 0) {
                        // è¿‡ç¨‹1ï¼šåŒ…å«åˆå§‹ä½ç½®
                        multiProcesses.push({
                            duration: 5 + Math.random() * 10, // 5-15ç§’
                            params: {
                                x0A: Math.floor(Math.random() * 200) - 100,
                                x0B: Math.floor(Math.random() * 200) + 50,
                                v0A: 5 + Math.random() * 20,
                                aA: (Math.random() > 0.5 ? 1 : -1) * Math.random() * 2,
                                v0B: Math.max(1, 5 + Math.random() * 15),
                                aB: (Math.random() > 0.5 ? 1 : -1) * Math.random() * 1.5,
                                brakeA: Math.random() > 0.7,
                                brakeB: Math.random() > 0.7
                            }
                        });
                    } else {
                        // åç»­è¿‡ç¨‹ï¼šä¸åŒ…å«åˆå§‹ä½ç½®
                        const lastProcess = multiProcesses[i-1];
                        multiProcesses.push({
                            duration: 5 + Math.random() * 10, // 5-15ç§’
                            params: {
                                x0A: null,
                                x0B: null,
                                v0A: lastProcess.params.v0A,
                                aA: (Math.random() > 0.5 ? 1 : -1) * Math.random() * 2,
                                v0B: lastProcess.params.v0B,
                                aB: (Math.random() > 0.5 ? 1 : -1) * Math.random() * 1.5,
                                brakeA: Math.random() > 0.7,
                                brakeB: Math.random() > 0.7
                            }
                        });
                    }
                }
                
                // æ›´æ–°ç•Œé¢
                updateProcessTabs();
                switchProcess(0);
            }
            
            // é‡ç½®æ—¶é—´
            singleParams.t = 0;
            
            // é‡ç½®è§†å›¾
            zoomToFit();
            
            // æ›´æ–°æ§ä»¶
            updateInputsAndSliders();
            
            // é‡æ–°è®¡ç®—
            if (currentMode === 'multi') {
                calculateProcessStates();
            }
            calculateSpecialMoments();
            
            // æ›´æ–°æ˜¾ç¤º
            drawMotion();
            updateCharts();
            updateInfoPanel();
            updateMomentsList();
        }
        
        // é¢„è®¾åœºæ™¯
        function setPreset(type) {
            stopAnimation();
            
            switch(type) {
                case 'chase': // åŒ€é€Ÿè¿½åŒ€é€Ÿ
                    singleParams.x0A = 0; singleParams.v0A = 12; singleParams.aA = 0;
                    singleParams.x0B = 40; singleParams.v0B = 5; singleParams.aB = 0;
                    brakeA.checked = false; brakeB.checked = false;
                    break;
                case 'accelerateChase': // åŒ€åŠ é€Ÿè¿½åŒ€é€Ÿ
                    singleParams.x0A = 0; singleParams.v0A = 5; singleParams.aA = 2;
                    singleParams.x0B = 50; singleParams.v0B = 8; singleParams.aB = 0;
                    brakeA.checked = false; brakeB.checked = false;
                    break;
                case 'decelerateChase': // åŒ€å‡é€Ÿè¿½åŒ€é€Ÿ
                    singleParams.x0A = 0; singleParams.v0A = 15; singleParams.aA = -1;
                    singleParams.x0B = 30; singleParams.v0B = 5; singleParams.aB = 0;
                    brakeA.checked = false; brakeB.checked = false;
                    break;
                case 'rearBrake': // åè½¦åˆ¹è½¦é—®é¢˜
                    singleParams.x0A = 0; singleParams.v0A = 20; singleParams.aA = -3;
                    singleParams.x0B = 50; singleParams.v0B = 10; singleParams.aB = 0;
                    brakeA.checked = true; brakeB.checked = false;
                    break;
                case 'bothBrake': // ä¸¤è½¦åŒæ—¶åˆ¹è½¦
                    singleParams.x0A = 0; singleParams.v0A = 25; singleParams.aA = -3;
                    singleParams.x0B = 60; singleParams.v0B = 15; singleParams.aB = -2;
                    brakeA.checked = true; brakeB.checked = true;
                    break;
                case 'cannotCatch': // æ°¸è¿œè¿½ä¸ä¸Š
                    singleParams.x0A = 0; singleParams.v0A = 5; singleParams.aA = 0;
                    singleParams.x0B = 30; singleParams.v0B = 10; singleParams.aB = 0;
                    brakeA.checked = false; brakeB.checked = false;
                    break;
                case 'meetAfterBrake': // åˆ¹è½¦åç›¸é‡
                    singleParams.x0A = 0; singleParams.v0A = 30; singleParams.aA = -2;
                    singleParams.x0B = 80; singleParams.v0B = 15; singleParams.aB = 0;
                    brakeA.checked = true; brakeB.checked = false;
                    break;
                case 'largeDisplacement': // å¤§ä½ç§»æ¼”ç¤º
                    singleParams.x0A = 0; singleParams.v0A = 40; singleParams.aA = 0;
                    singleParams.x0B = 500; singleParams.v0B = 10; singleParams.aB = 0;
                    brakeA.checked = false; brakeB.checked = false;
                    singleParams.maxT = 30;
                    viewMode = 'largeDisplacement';
                    viewRangeSelect.value = 'largeDisplacement';
                    break;
                case 'multiProcessDemo': // å¤šè¿‡ç¨‹æ¼”ç¤º
                    switchMode('multi');
                    multiProcesses = [
                        {
                            duration: 5,
                            params: {
                                x0A: 0,
                                x0B: 40,
                                v0A: 10, 
                                aA: 0, 
                                v0B: 5, 
                                aB: 0,
                                brakeA: false, 
                                brakeB: false
                            }
                        },
                        {
                            duration: 5,
                            params: {
                                x0A: null,
                                x0B: null,
                                v0A: 10, 
                                aA: -2, 
                                v0B: 5, 
                                aB: 0,
                                brakeA: true, 
                                brakeB: false
                            }
                        },
                        {
                            duration: 5,
                            params: {
                                x0A: null,
                                x0B: null,
                                v0A: 0, 
                                aA: 1, 
                                v0B: 5, 
                                aB: -1,
                                brakeA: false, 
                                brakeB: true
                            }
                        }
                    ];
                    updateProcessTabs();
                    switchProcess(0);
                    calculateProcessStates();
                    zoomToFit();
                    break;
            }
            
            // é‡ç½®æ—¶é—´
            singleParams.t = 0;
            
            // æ›´æ–°æ§ä»¶
            updateInputsAndSliders();
            
            // é‡æ–°è®¡ç®—
            calculateSpecialMoments();
            
            // æ›´æ–°æ˜¾ç¤º
            drawMotion();
            updateCharts();
            updateInfoPanel();
            updateMomentsList();
        }
        
        // ==================== äº‹ä»¶ç»‘å®š ====================
        
        // ç»‘å®šäº‹ä»¶
        function bindEvents() {
            // å•è¿‡ç¨‹æ»‘å—äº‹ä»¶
            for (const key in singleSliders) {
                singleSliders[key].addEventListener('input', function() {
                    const value = parseFloat(this.value);
                    if (key === 'time') {
                        singleParams.t = value;
                        singleInputs.time.value = value.toFixed(1);
                    } else {
                        singleParams[key] = value;
                        singleInputs[key].value = value.toFixed(1);
                        calculateSpecialMoments();
                    }
                    stopAnimation();
                    drawMotion();
                    updateCharts();
                    updateInfoPanel();
                });
            }
            
            // å•è¿‡ç¨‹è¾“å…¥æ¡†äº‹ä»¶
            for (const key in singleInputs) {
                singleInputs[key].addEventListener('change', function() {
                    let value = parseFloat(this.value) || 0;
                    const min = parseFloat(this.min);
                    const max = parseFloat(this.max);
                    value = Math.max(min, Math.min(max, value));
                    
                    if (key === 'time') {
                        singleParams.t = value;
                        singleSliders.time.value = value;
                    } else {
                        singleParams[key] = value;
                        singleSliders[key].value = value;
                        calculateSpecialMoments();
                    }
                    stopAnimation();
                    drawMotion();
                    updateCharts();
                    updateInfoPanel();
                });
            }
            
            // å¤šè¿‡ç¨‹æ»‘å—äº‹ä»¶
            for (const key in multiSliders) {
                multiSliders[key].addEventListener('input', function() {
                    const value = parseFloat(this.value);
                    const process = multiProcesses[currentProcessIndex];
                    
                    if (key === 'duration') {
                        process.duration = value;
                        multiInputs.duration.value = value.toFixed(1);
                    } else if (key === 'x0A' || key === 'x0B') {
                        // åˆå§‹ä½ç½®ï¼ˆä»…è¿‡ç¨‹1æœ‰æ•ˆï¼‰
                        if (currentProcessIndex === 0) {
                            process.params[key] = value;
                            multiInputs[key].value = value.toFixed(1);
                        }
                    } else {
                        process.params[key] = value;
                        multiInputs[key].value = value.toFixed(1);
                    }
                    
                    calculateProcessStates();
                    calculateSpecialMoments();
                    stopAnimation();
                    drawMotion();
                    updateCharts();
                    updateInfoPanel();
                });
            }
            
            // å¤šè¿‡ç¨‹è¾“å…¥æ¡†äº‹ä»¶
            for (const key in multiInputs) {
                multiInputs[key].addEventListener('change', function() {
                    let value = parseFloat(this.value) || 0;
                    const min = parseFloat(this.min);
                    const max = parseFloat(this.max);
                    value = Math.max(min, Math.min(max, value));
                    
                    const process = multiProcesses[currentProcessIndex];
                    
                    if (key === 'duration') {
                        process.duration = value;
                        multiSliders.duration.value = value;
                    } else if (key === 'x0A' || key === 'x0B') {
                        // åˆå§‹ä½ç½®ï¼ˆä»…è¿‡ç¨‹1æœ‰æ•ˆï¼‰
                        if (currentProcessIndex === 0) {
                            process.params[key] = value;
                            multiSliders[key].value = value;
                        }
                    } else {
                        process.params[key] = value;
                        multiSliders[key].value = value;
                    }
                    
                    calculateProcessStates();
                    calculateSpecialMoments();
                    stopAnimation();
                    drawMotion();
                    updateCharts();
                    updateInfoPanel();
                });
            }
            
            // å¤šè¿‡ç¨‹å¤é€‰æ¡†äº‹ä»¶
            multiBrakeA.addEventListener('change', () => {
                multiProcesses[currentProcessIndex].params.brakeA = multiBrakeA.checked;
                calculateSpecialMoments();
                drawMotion();
            });
            
            multiBrakeB.addEventListener('change', () => {
                multiProcesses[currentProcessIndex].params.brakeB = multiBrakeB.checked;
                calculateSpecialMoments();
                drawMotion();
            });
            
            // æŒ‰é’®äº‹ä»¶
            playBtn.addEventListener('click', startAnimation);
            pauseBtn.addEventListener('click', stopAnimation);
            resetBtn.addEventListener('click', resetAnimation);
            toStartBtn.addEventListener('click', backToStart);
            randomBtn.addEventListener('click', randomGenerate);
            
            // è§†å›¾æ§åˆ¶æŒ‰é’®äº‹ä»¶
            zoomInBtn.addEventListener('click', zoomIn);
            zoomOutBtn.addEventListener('click', zoomOut);
            zoomFitBtn.addEventListener('click', zoomToFit);
            resetViewBtn.addEventListener('click', resetView);
            
            // è§†å›¾æ¨¡å¼é€‰æ‹©
            viewRangeSelect.addEventListener('change', function() {
                viewMode = this.value;
                drawMotion();
                updateViewInfo();
            });
            
            // å¤é€‰æ¡†äº‹ä»¶
            brakeA.addEventListener('change', () => {
                calculateSpecialMoments();
                drawMotion();
            });
            
            brakeB.addEventListener('change', () => {
                calculateSpecialMoments();
                drawMotion();
            });
            
            // æ˜¾ç¤ºé€‰é¡¹äº‹ä»¶
            document.getElementById('showAllMoments').addEventListener('change', drawMotion);
            document.getElementById('showVelocity').addEventListener('change', drawMotion);
            document.getElementById('showTrajectory').addEventListener('change', drawMotion);
            document.getElementById('showStopPosition').addEventListener('change', drawMotion);
            document.getElementById('showBrakeLight').addEventListener('change', drawMotion);
            document.getElementById('showProcessMarkers').addEventListener('change', drawMotion);
            document.getElementById('showScaleIndicator').addEventListener('change', drawMotion);
            
            // ==================== é¼ æ ‡äº¤äº’äº‹ä»¶ ====================
            
            // é¼ æ ‡æ»šè½®ç¼©æ”¾
            canvas.addEventListener('wheel', function(e) {
                e.preventDefault();
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mousePosition = canvasXToPosition(mouseX);
                
                // è®¡ç®—ç¼©æ”¾ä¸­å¿ƒ
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const oldZoom = zoomLevel;
                zoomLevel *= zoomFactor;
                zoomLevel = Math.max(0.05, Math.min(zoomLevel, 20));
                
                // è°ƒæ•´è§†å›¾ä¸­å¿ƒï¼Œä½¿é¼ æ ‡ä½ç½®ä¿æŒä¸å˜
                const zoomRatio = oldZoom / zoomLevel;
                viewCenter = mousePosition - (mousePosition - viewCenter) * zoomRatio;
                
                // æ›´æ–°æ˜¾ç¤ºæ¨¡å¼
                if (viewMode !== 'followCurrent') {
                    viewMode = 'followCurrent';
                    viewRangeSelect.value = 'followCurrent';
                }
                
                drawMotion();
                updateViewInfo();
            });
            
            // é¼ æ ‡æ‹–æ‹½å¹³ç§»
            canvas.addEventListener('mousedown', function(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // æ£€æŸ¥æ˜¯å¦åœ¨ç”»å¸ƒçš„ä¸»è¦åŒºåŸŸï¼ˆæ’é™¤æŒ‰é’®ç­‰ï¼‰
                if (mouseY > 80 && mouseY < canvas.height - 30) {
                    isDragging = true;
                    lastMouseX = mouseX;
                    lastMouseY = mouseY;
                    canvas.style.cursor = 'grabbing';
                }
            });
            
            canvas.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const deltaX = mouseX - lastMouseX;
                
                // è®¡ç®—å¹³ç§»è·ç¦»
                const range = getViewRange();
                const rangeWidth = range.maxX - range.minX;
                const deltaPos = (deltaX / (canvas.width - 100)) * rangeWidth;
                
                viewCenter -= deltaPos;
                lastMouseX = mouseX;
                
                // æ›´æ–°æ˜¾ç¤ºæ¨¡å¼
                if (viewMode !== 'followCurrent') {
                    viewMode = 'followCurrent';
                    viewRangeSelect.value = 'followCurrent';
                }
                
                drawMotion();
                updateViewInfo();
            });
            
            canvas.addEventListener('mouseup', function() {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            canvas.addEventListener('mouseleave', function() {
                isDragging = false;
                canvas.style.cursor = 'grab';
            });
            
            // åŒå‡»å±…ä¸­æ˜¾ç¤ºç‰©ä½“
            canvas.addEventListener('dblclick', function(e) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // æ£€æŸ¥ç‚¹å‡»ä½ç½®
                const width = canvas.width;
                const height = canvas.height;
                
                // è®¡ç®—ç‚¹å‡»ä½ç½®å¯¹åº”çš„ç‰©ä½“
                const t = currentMode === 'single' ? singleParams.t : singleParams.t;
                const xA = calculatePosition('A', t);
                const xB = calculatePosition('B', t);
                
                const scaledXA = positionToCanvasX(xA);
                const scaledXB = positionToCanvasX(xB);
                
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†Aè½¦
                if (Math.abs(mouseX - scaledXA) < 30 && Math.abs(mouseY - height/2) < 20) {
                    centerOnObject('A');
                }
                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†Bè½¦
                else if (Math.abs(mouseX - scaledXB) < 30 && Math.abs(mouseY - height/2) < 20) {
                    centerOnObject('B');
                }
            });
            
            // çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', () => {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = 300;
                drawMotion();
                drawProcessMarkers();
                
                if (sChart) sChart.resize();
                if (vChart) vChart.resize();
                if (aChart) aChart.resize();
                if (dChart) dChart.resize();
            });
        }
        
        // ==================== åˆå§‹åŒ– ====================
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        window.onload = init;
    </script>
</body>
</html>
